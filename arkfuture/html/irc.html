<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8" version="1.7">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="description" content="ARKFUTURE-NET IRC">
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
	<title>IRC Web Client</title>
	<style>
		:root {
			--cyber-primary: #00f0ff;
			--cyber-secondary: #ff00ff;
			--cyber-accent: #ffff00;
			--cyber-green: #00ff00;
			--cyber-red: #ff0040;
			--cyber-dark: #0a0a0a;
			--cyber-dark2: #111111;
			--cyber-dark3: #1a1a1a;
			--cyber-border: #333333;
			--cyber-text: #e0e0e0;
			--cyber-text-dim: #888888;
			--glow-primary: 0 0 10px #00f0ff, 0 0 20px #00f0ff40, 0 0 30px #00f0ff20;
			--glow-secondary: 0 0 10px #ff00ff, 0 0 20px #ff00ff40, 0 0 30px #ff00ff20;
			--glow-red: 0 0 10px #ff0040, 0 0 20px #ff004040;
			--spacing-xs: 4px;
			--spacing-sm: 8px;
			--spacing-md: 12px;
			--spacing-lg: 16px;
			--spacing-xl: 24px;
			--border-radius-sm: 2px;
			--border-radius: 4px;
			--transition: all 0.15s ease-out;

			/* 消息颜色别名 */
			--clr-font: var(--cyber-text);
			--clr-info: var(--cyber-primary);
			--clr-success: var(--cyber-green);
			--clr-warning: var(--cyber-accent);
			--clr-error: var(--cyber-red);
			--clr-red: var(--cyber-red);
			--clr-green: var(--cyber-green);
			--clr-blue: var(--cyber-primary);
			--clr-purple: var(--cyber-secondary);
			--clr-gold: var(--cyber-accent);
			--clr-brown: #cd853f;
			--clr-accent: var(--cyber-accent);
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		html,
		body {
			font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
			height: 100%;
			background-color: var(--cyber-dark);
			color: var(--cyber-text);
			font-size: 13px;
			line-height: 1.5;
			overflow: hidden;
		}

		.main {
			display: flex;
			flex-direction: column;
			height: 100vh;
			overflow: hidden;
			background: linear-gradient(180deg, #0a0a0a 0%, #0d0d0d 100%);
		}

		.header {
			background: var(--cyber-dark2);
			border-bottom: 1px solid var(--cyber-border);
			padding: var(--spacing-sm) var(--spacing-lg);
			flex: 0 0 auto;
			display: flex;
			justify-content: space-between;
			align-items: center;
			position: relative;
		}

		.header h1 {
			font-size: 16px;
			font-weight: 600;
			color: var(--cyber-primary);
			text-transform: uppercase;
			letter-spacing: 2px;
			text-shadow: var(--glow-primary);
			margin: 0;
		}

		.header-menu {
			position: relative;
		}

		.header-menu-btn {
			background: transparent;
			color: var(--cyber-primary);
			border: none;
			padding: var(--spacing-sm) var(--spacing-md);
			cursor: pointer;
			font-size: 11px;
			transition: var(--transition);
			text-transform: uppercase;
			letter-spacing: 1px;
			font-family: 'Courier New', 'Consolas', monospace;
		}

		.header-menu-btn:hover {
			color: var(--cyber-secondary);
			text-shadow: var(--glow-secondary);
		}

		.header-menu-dropdown {
			position: absolute;
			top: calc(100% + 5px);
			right: 0;
			background: var(--cyber-dark2);
			border: 1px solid var(--cyber-border);
			min-width: 150px;
			z-index: 9999;
			display: none;
			box-shadow: 0 0 30px rgba(0, 240, 255, 0.1);
		}

		.header-menu-dropdown.visible {
			display: block;
		}

		.header-menu-dropdown::before {
			content: '';
			position: absolute;
			top: -6px;
			right: 10px;
			width: 10px;
			height: 10px;
			background: var(--cyber-dark2);
			border: 1px solid var(--cyber-border);
			transform: rotate(45deg);
			border-bottom: none;
			border-right: none;
		}

		.header-menu-item {
			padding: var(--spacing-sm) var(--spacing-md);
			cursor: pointer;
			font-size: 11px;
			transition: var(--transition);
			text-transform: uppercase;
			letter-spacing: 0.5px;
			border-bottom: 1px solid var(--cyber-dark3);
			color: var(--cyber-text);
			font-family: 'Courier New', 'Consolas', monospace;
		}

		.header-menu-item:last-child {
			border-bottom: none;
		}

		.header-menu-item:hover {
			background: var(--cyber-primary);
			color: var(--cyber-dark);
			box-shadow: var(--glow-primary);
		}

		.header-menu-item.active {
			background: var(--cyber-green);
			color: var(--cyber-dark);
		}

		.settings-bar {
			display: flex;
			flex-wrap: wrap;
			gap: var(--spacing-md);
			padding: var(--spacing-md) var(--spacing-lg);
			background-color: var(--cyber-dark2);
			border-bottom: 1px solid var(--cyber-border);
			align-items: center;
		}

		.settings-bar .settings-group {
			flex: 0 0 auto;
		}

		.settings-inputs {
			display: flex;
			gap: var(--spacing-md);
			flex-wrap: wrap;
			align-items: center;
			flex: 1;
			min-width: 0;
		}

		.settings-inputs .settings-group {
			flex: 0 0 auto;
			min-width: 140px;
			max-width: 250px;
		}

		.settings-actions {
			display: flex;
			gap: var(--spacing-md);
			align-items: center;
			flex: 0 0 auto;
		}

		.settings-group {
			display: flex;
			flex-direction: column;
			gap: var(--spacing-xs);
		}

		.settings-group label {
			font-size: 10px;
			color: var(--cyber-text-dim);
			white-space: nowrap;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.settings-group input[type="text"],
		.settings-group input[type="password"] {
			padding: var(--spacing-sm) var(--spacing-md);
			background-color: var(--cyber-dark);
			color: var(--cyber-text);
			border: 1px solid var(--cyber-border);
			font-size: 12px;
			width: auto;
			min-width: 140px;
			max-width: 200px;
			transition: var(--transition);
			font-family: 'Courier New', 'Consolas', monospace;
		}

		.settings-group input[type="text"]:focus,
		.settings-group input[type="password"]:focus {
			outline: none;
			border-color: var(--cyber-primary);
			box-shadow: var(--glow-primary);
		}

		.settings-group input[type="checkbox"] {
			width: 14px;
			height: 14px;
			cursor: pointer;
			margin: 0;
			accent-color: var(--cyber-primary);
		}

		.settings-group.checkbox-label {
			flex-direction: row;
			align-items: center;
			gap: var(--spacing-sm);
			cursor: pointer;
			padding: var(--spacing-sm);
			background: var(--cyber-dark);
			border: 1px solid var(--cyber-border);
			transition: var(--transition);
		}

		.settings-group.checkbox-label:hover {
			border-color: var(--cyber-primary);
		}

		.settings-group.checkbox-label input[type="checkbox"] {
			margin: 0;
		}

		.settings-group select {
			padding: var(--spacing-sm);
			background-color: var(--cyber-dark);
			color: var(--cyber-text);
			border: 1px solid var(--cyber-border);
			font-size: 12px;
			width: 100%;
			transition: var(--transition);
			font-family: 'Courier New', 'Consolas', monospace;
			cursor: pointer;
		}

		.settings-group select:focus {
			outline: none;
			border-color: var(--cyber-primary);
			box-shadow: var(--glow-primary);
		}

		.settings-group select option {
			background: var(--cyber-dark);
			color: var(--cyber-text);
		}

		.settings-inline {
			display: flex;
			align-items: center;
			gap: var(--spacing-md);
			padding: var(--spacing-sm) var(--spacing-md);
			background: var(--cyber-dark);
			border: 1px solid var(--cyber-border);
			transition: var(--transition);
		}

		.settings-inline:hover {
			border-color: var(--cyber-primary);
		}

		.btn {
			padding: var(--spacing-sm) var(--spacing-lg);
			background: transparent;
			color: var(--cyber-primary);
			border: 1px solid var(--cyber-primary);
			cursor: pointer;
			font-size: 11px;
			white-space: nowrap;
			transition: var(--transition);
			text-transform: uppercase;
			letter-spacing: 1px;
			font-family: 'Courier New', 'Consolas', monospace;
		}

		.btn:hover {
			background: var(--cyber-primary);
			color: var(--cyber-dark);
			box-shadow: var(--glow-primary);
		}

		.connect-btn {
			border-color: var(--cyber-green);
			color: var(--cyber-green);
		}

		.connect-btn:hover {
			background: var(--cyber-green);
			box-shadow: 0 0 10px #00ff00, 0 0 20px #00ff0040;
		}

		.connect-btn:disabled {
			border-color: var(--cyber-border);
			color: var(--cyber-text-dim);
			cursor: not-allowed;
		}

		.connect-btn:disabled:hover {
			background: transparent;
			box-shadow: none;
		}

		.connect-btn.disconnect {
			border-color: var(--cyber-red);
			color: var(--cyber-red);
		}

		.connect-btn.disconnect:hover {
			background: var(--cyber-red);
			box-shadow: var(--glow-red);
		}

		.connection-status {
			display: inline-flex;
			align-items: center;
			gap: var(--spacing-sm);
			padding: var(--spacing-sm) var(--spacing-lg);
			background-color: var(--cyber-dark3);
			border: 1px solid var(--cyber-border);
			font-size: 10px;
			margin-left: auto;
			flex: 0 0 auto;
			transition: var(--transition);
			text-transform: uppercase;
			letter-spacing: 1px;
			min-height: 32px;
			box-sizing: border-box;
		}

		.connection-status.connected {
			border-color: var(--cyber-green);
			color: var(--cyber-green);
			box-shadow: 0 0 10px #00ff0040;
		}

		.connection-status.connecting {
			border-color: var(--cyber-accent);
			color: var(--cyber-accent);
			animation: pulse 1s ease-in-out infinite;
		}

		.connection-status.disconnected {
			border-color: var(--cyber-red);
			color: var(--cyber-red);
		}

		.connection-status .indicator {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background-color: var(--cyber-border);
			transition: var(--transition);
		}

		.connection-status.connected .indicator {
			background-color: var(--cyber-green);
			box-shadow: 0 0 10px #00ff00;
		}

		.connection-status.connecting .indicator {
			background-color: var(--cyber-accent);
			box-shadow: 0 0 10px #ffff00;
			animation: pulse 1s ease-in-out infinite;
		}

		.connection-status.disconnected .indicator {
			background-color: var(--cyber-red);
			box-shadow: 0 0 10px #ff0040;
		}

		@keyframes pulse {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}
		}

		@keyframes glow {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.7;
			}
		}

		.ssl-warning {
			display: none;
			position: absolute;
			bottom: 20px;
			right: 20px;
			max-width: 380px;
			background: var(--cyber-dark2);
			border: 1px solid var(--cyber-accent);
			color: var(--cyber-text);
			padding: var(--spacing-md);
			font-size: 12px;
			z-index: 200;
			box-shadow: 0 0 20px rgba(255, 255, 0, 0.2);
			line-height: 1.4;
		}

		.ssl-warning.visible {
			display: block;
		}

		.ssl-warning a {
			color: var(--cyber-primary);
			text-decoration: underline;
			cursor: pointer;
		}

		.ssl-warning code {
			background: var(--cyber-dark3);
			padding: 2px 4px;
			border: 1px solid var(--cyber-border);
			font-family: 'Courier New', monospace;
		}

		.chat-container {
			flex: 1 1 auto;
			display: flex;
			flex-direction: column;
			overflow: hidden;
			position: relative;
			min-height: 0;
			background-color: var(--cyber-dark);
		}

		.input-container {
			flex: 0 0 auto;
			display: flex;
			gap: var(--spacing-sm);
			padding: var(--spacing-sm);
			background-color: var(--cyber-dark3);
			border-top: 1px solid var(--cyber-border);
			align-items: center;
		}

		.input-container input {
			flex: 1;
		}

		.channels {
			flex: 0 0 auto;
			background-color: var(--cyber-dark2);
			border-bottom: 1px solid var(--cyber-border);
			display: flex;
			align-items: center;
			padding: var(--spacing-xs) var(--spacing-sm);
			gap: var(--spacing-sm);
			overflow-x: auto;
			flex-wrap: nowrap;
			position: relative;
		}

		.channels::-webkit-scrollbar {
			height: 3px;
		}

		.channel {
			padding: var(--spacing-xs) var(--spacing-md);
			background-color: var(--cyber-dark3);
			border: 1px solid var(--cyber-border);
			cursor: pointer;
			font-size: 11px;
			transition: var(--transition);
			display: inline-flex;
			align-items: center;
			gap: var(--spacing-xs);
			white-space: nowrap;
			position: relative;
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		.channel:hover {
			border-color: var(--cyber-primary);
		}

		.channel.active {
			background: var(--cyber-primary);
			color: var(--cyber-dark);
			border-color: var(--cyber-primary);
			box-shadow: var(--glow-primary);
		}

		.channel .unread-badge {
			position: absolute;
			top: -4px;
			right: -4px;
			background-color: var(--cyber-red);
			color: var(--cyber-dark);
			font-size: 9px;
			padding: 1px 4px;
			font-weight: 700;
			min-width: 14px;
			text-align: center;
			box-shadow: var(--glow-red);
		}

		.channel button.x {
			background: none;
			border: none;
			color: inherit;
			cursor: pointer;
			padding: 2px 4px;
			font-weight: bold;
			font-size: 12px;
			transition: var(--transition);
			line-height: 1;
			opacity: 0.7;
		}

		.channel button.x:hover {
			opacity: 1;
		}

		.channel:not(.active) button.x {
			opacity: 0;
		}

		.channel:not(.active):hover button.x {
			opacity: 0.5;
		}

		.log-container {
			position: absolute;
			inset: 0;
			background-color: var(--cyber-dark2);
			border-bottom: 1px solid var(--cyber-primary);
			display: none;
			flex-direction: column;
			z-index: 100;
			box-shadow: 0 0 30px rgba(0, 240, 255, 0.15);
		}

		.log-container.visible {
			display: flex;
		}

		.log-header {
			flex: 0 0 auto;
			padding: var(--spacing-sm) var(--spacing-md);
			background-color: var(--cyber-dark3);
			border-bottom: 1px solid var(--cyber-border);
			display: flex;
			justify-content: space-between;
			align-items: center;
			font-size: 11px;
			min-height: 30px;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: var(--cyber-primary);
		}

		.log-controls {
			display: flex;
			gap: var(--spacing-xs);
		}

		.log-controls button {
			padding: 3px 8px;
			background: transparent;
			border: 1px solid var(--cyber-border);
			color: var(--cyber-text-dim);
			cursor: pointer;
			font-size: 10px;
			transition: var(--transition);
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		.log-controls button:hover {
			border-color: var(--cyber-primary);
			color: var(--cyber-primary);
			box-shadow: var(--glow-primary);
		}

		#logOutput {
			flex: 1 1 auto;
			overflow-y: auto;
			padding: var(--spacing-sm);
			font-size: 11px;
			font-family: 'Courier New', 'Consolas', monospace;
			background-color: var(--cyber-dark3);
			color: var(--cyber-text);
			white-space: pre-wrap;
			word-wrap: break-word;
			line-height: 1.4;
			user-select: all;
			-webkit-user-select: all;
			-moz-user-select: all;
			-ms-user-select: all;
		}

		#logOutput:empty::before {
			content: '[ NO DATA ]';
			color: var(--cyber-text-dim);
		}

		.channelcontents-wrapper {
			flex: 1 1 auto;
			display: flex;
			overflow: hidden;
			min-height: 0;
		}

		.channelcontents-wrapper.visible {
			display: flex;
		}

		.channelcontents-wrapper.hidden {
			display: none;
		}

		.channelcontents {
			display: flex;
			flex-direction: row;
			width: 100%;
			height: 100%;
			min-height: 0;
		}

		.channelcontent {
			flex: 1 1 auto;
			display: none;
			flex-direction: row;
			min-height: 0;
		}

		.channelcontent.active {
			display: flex;
		}

		.channelcontent nav {
			flex: 1 1 auto;
			display: flex;
			flex-direction: column;
			background-color: var(--cyber-dark3);
			overflow: hidden;
			border: 1px solid var(--cyber-border);
		}

		.channelcontent nav h3 {
			flex: 0 0 auto;
			padding: var(--spacing-sm) var(--spacing-md);
			margin: 0;
			background-color: var(--cyber-dark2);
			border-bottom: 1px solid var(--cyber-border);
			font-size: 12px;
			min-height: 35px;
			display: flex;
			align-items: center;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: var(--cyber-primary);
		}

		.channelcontent nav nav {
			flex: 1 1 auto;
			overflow-y: auto;
			padding: var(--spacing-md);
			min-height: 0;
		}

		.channelcontent nav p {
			margin: 0;
			padding: var(--spacing-sm) 0;
			line-height: 1.5;
		}

		ul {
			flex: 0 0 200px;
			overflow-y: auto;
			padding: var(--spacing-sm);
			margin: 0;
			border-left: 1px solid var(--cyber-border);
			list-style: none;
			background-color: var(--cyber-dark2);
			min-height: 0;
		}

		.channelcontents li {
			padding: var(--spacing-xs) var(--spacing-sm);
			margin: 1px 0;
			display: flex;
			gap: var(--spacing-sm);
			transition: var(--transition);
			cursor: pointer;
			align-items: center;
			font-size: 11px;
		}

		.channelcontents li:hover {
			background-color: var(--cyber-dark3);
		}

		.channelcontents li p {
			margin: 0;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.channelcontents li p:first-child {
			width: 18px;
			color: var(--cyber-secondary);
			font-weight: bold;
			text-align: center;
			flex-shrink: 0;
		}

		.channelcontents li p:nth-child(2) {
			flex: 1;
			color: var(--cyber-text);
		}

		.message {
			padding: var(--spacing-xs) var(--spacing-md);
			margin-bottom: 1px;
			transition: var(--transition);
		}

		.message:hover {
			background-color: var(--cyber-dark2);
		}

		.message .timestamp {
			color: var(--cyber-text-dim);
			font-size: 10px;
			margin-right: var(--spacing-sm);
		}

		.message .username {
			font-weight: 600;
			margin-right: var(--spacing-sm);
			color: var(--cyber-secondary);
		}

		.message .content {
			word-wrap: break-word;
			line-height: 1.5;
		}

		.message .content a {
			color: var(--cyber-primary);
			text-decoration: none;
		}

		.message .content a:hover {
			text-decoration: underline;
		}

		#input {
			flex: 1;
			padding: var(--spacing-sm) var(--spacing-md);
			background-color: var(--cyber-dark);
			color: var(--cyber-text);
			border: 1px solid var(--cyber-border);
			font-size: 13px;
			transition: var(--transition);
			font-family: 'Courier New', 'Consolas', monospace;
		}

		#input:focus {
			outline: none;
			border-color: var(--cyber-primary);
			box-shadow: var(--glow-primary);
		}

		#input::placeholder {
			color: var(--cyber-text-dim);
		}

		/* 自定义滚动条 */
		::-webkit-scrollbar {
			width: 6px;
			height: 6px;
		}

		::-webkit-scrollbar-track {
			background: var(--cyber-dark2);
		}

		::-webkit-scrollbar-thumb {
			background: var(--cyber-border);
			transition: var(--transition);
		}

		::-webkit-scrollbar-thumb:hover {
			background: var(--cyber-primary);
			box-shadow: var(--glow-primary);
		}

		/* Firefox滚动条 */
		* {
			scrollbar-width: thin;
			scrollbar-color: var(--cyber-border) var(--cyber-dark2);
		}

		/* 移动端优化 */
		@media (max-width: 768px) {
			.settings-bar {
				flex-direction: column;
				gap: var(--spacing-sm);
				padding: var(--spacing-sm) var(--spacing-md);
			}

			.settings-inputs {
				flex-direction: column;
				width: 100%;
				gap: var(--spacing-sm);
			}

			.settings-inputs .settings-group {
				width: 100%;
				flex: 1 1 auto;
				min-width: unset;
				max-width: unset;
			}

			.settings-group {
				width: 100%;
			}

			.settings-group input[type="text"],
			.settings-group input[type="password"] {
				width: 100%;
				min-width: unset;
				padding: var(--spacing-sm) var(--spacing-md);
			}

			.settings-group label {
				font-size: 10px;
			}

			.settings-actions {
				width: 100%;
				justify-content: space-between;
			}

			.header h1 {
				font-size: 14px;
			}

			.header-menu-btn {
				font-size: 10px;
				padding: var(--spacing-xs) var(--spacing-sm);
			}

			.connection-status {
				margin-left: auto;
				flex: 0 0 auto;
				padding: 4px 8px;
				font-size: 9px;
			}

			.connection-status span:last-child {
				display: none;
			}

			.log-container {
				height: 40vh;
			}

			.channelcontent {
				flex-direction: column;
			}

			ul {
				flex: 0 0 120px;
				border-left: none;
				border-top: 1px solid var(--cyber-border);
			}

			#input {
				margin: var(--spacing-sm);
				padding: var(--spacing-sm) var(--spacing-md);
				font-size: 16px;
				/* 防止iOS自动缩放 */
			}

			.input-container {
				padding: var(--spacing-sm);
			}

			.channel {
				font-size: 10px;
				padding: 4px 10px;
			}

			.unread-badge {
				top: -3px;
				right: -3px;
				font-size: 8px;
				padding: 1px 4px;
				min-width: 12px;
			}
		}

		@media (max-width: 480px) {
			.header h1 {
				font-size: 12px;
			}

			.header h1::before {
				font-size: 18px;
			}

			ul {
				flex: 0 0 100px;
			}

			.log-header {
				padding: var(--spacing-sm);
			}

			.btn {
				padding: 6px 10px;
				font-size: 10px;
			}
		}

		/* 超小屏幕 */
		@media (max-width: 360px) {
			.channel {
				padding: 3px 6px;
				font-size: 10px;
			}
		}

		/* 空状态提示 */
		.empty-state {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			height: 100%;
			color: var(--cyber-text-dim);
			text-align: center;
			padding: var(--spacing-lg);
		}

		.empty-state h3 {
			margin: 0 0 8px 0;
			font-size: 14px;
			text-transform: uppercase;
			letter-spacing: 1px;
			color: var(--cyber-primary);
		}

		.empty-state p {
			margin: 0;
			font-size: 12px;
		}
	</style>
</head>

<body>
	<div class="main">
		<div class="header">
			<h1 id="caption">IRC Client</h1>
			<div class="header-menu">
				<button class="header-menu-btn" onclick="toggleHeaderMenu()">菜单</button>
				<div class="header-menu-dropdown" id="headerMenuDropdown">
					<div class="header-menu-item" onclick="toggleLog()">查看日志</div>
					<div class="header-menu-item" onclick="showSSLWarning()">SSL帮助</div>
					<div class="header-menu-item" onclick="toggleAutoReconnect()">自动重连</div>
				</div>
			</div>
		</div>

		<div class="settings-bar">
			<div class="settings-inputs">
				<div class="settings-group">
					<label>WebSocket:</label>
					<input type="text" id="wsUrl" value="wss://irc.arkfuture.top:8097" placeholder="wss://irc.example.com:port/">
				</div>
				<div class="settings-group">
					<label>昵称:</label>
					<input type="text" id="nickInput" value="" placeholder="输入昵称">
				</div>
				<div class="settings-group">
					<label>频道:</label>
					<input type="text" id="channelInput" value="#lobby" placeholder="#channe">
				</div>
				<!-- 隐藏的自动重连复选框, 保持功能性 -->
				<input type="checkbox" id="autoReconnect" style="display: none;">
			</div>
			<div class="settings-actions">
				<button class="btn connect-btn" id="connectBtn" onclick="toggleConnection()">连接</button>
				<div class="connection-status disconnected" id="connectionStatus">
					<span class="indicator"></span>
					<span id="statusText">未连接</span>
				</div>
			</div>
		</div>

		<div class="ssl-warning" id="sslWarning">
			<strong>⚠️ 浏览器无法忽略SSL证书错误!</strong> 请使用以下方案: <br>
			1. 改用 <code>ws://</code> 非加密连接(如果浏览器支持)<br>
			2. 在浏览器中访问 <a id="sslLink" target="_blank">服务器URL</a> 并手动信任证书<br>
		</div>

		<div class="log-container" id="logContainer">
			<div class="log-header">
				<span>WebSocket日志</span>
				<div class="log-controls">
					<button onclick="clearLog()">清空</button>
					<button onclick="toggleLog()">关闭</button>
				</div>
			</div>
			<div id="logOutput"></div>
		</div>

		<div class="chat-container">
			<div class="channels" id="channelsContainer"></div>
			<div class="channelcontents-wrapper hidden" id="contentsWrapper">
				<div class="channelcontents" id="channelContents"></div>
			</div>
			<div class="empty-state" id="emptyState">
				<h3>欢迎使用 IRC 客户端</h3>
				<p>请先填写服务器信息并点击连接</p>
			</div>
			<div class="input-container" id="inputContainer" style="display: none;">
				<input type="text" name="input" id="input" placeholder="输入消息..."
					   onkeydown="onKeyDown(event)" />
			</div>
		</div>
	</div>
</body>

<script>
	let nickname = "";
	let channelName = "";
	let wsUrl = "";
	let channels, channelContents, contentsWrapper, emptyState, input;
	let channelMap = new Map();
	let activeChannel = null;
	let statusChannel = null;
	let PrefixChars;
	let websocket = null;
	let isConnected = false;
	let autoReconnect = false;
	let reconnectAttempts = 0;
	const maxReconnectAttempts = 5;
	const reconnectDelay = 3000;
	let keepAliveTimer = null;
	const keepAliveInterval = 90000;
	let inputBlurTimeoutId = null;
	let messageHistory = [];
	let historyIndex = -1;
	let isDisconnecting = false;

	function onLoad() {
		channels = document.getElementById("channelsContainer");
		channelContents = document.getElementById("channelContents");
		contentsWrapper = document.getElementById("contentsWrapper");
		emptyState = document.getElementById("emptyState");
		input = document.getElementById("input");

		loadSettings();

		let url = new URL(document.location);
		if (url.hash) {
			document.getElementById('channelInput').value = url.hash;
		}
		if (window.frameElement) {
			document.getElementById("caption").style.display = "none";
		}
		updateConnectionStatus('disconnected');

		if (input) {
			input.addEventListener('blur', handleInputBlur);
		}
	}

	function saveSettings() {
		try {
			const settings = {
				wsUrl: document.getElementById('wsUrl').value,
				nickname: document.getElementById('nickInput').value,
				channel: document.getElementById('channelInput').value,
				autoReconnect: document.getElementById('autoReconnect').checked
			};
			localStorage.setItem('ircSettings', JSON.stringify(settings));
		} catch (e) {
			writeToLog(`[WARN] 保存设置失败: ${e.message}`);
		}
	}

	function loadSettings() {
		try {
			const settings = JSON.parse(localStorage.getItem('ircSettings') || '{}');
			if (settings.wsUrl) document.getElementById('wsUrl').value = settings.wsUrl;
			if (settings.nickname) document.getElementById('nickInput').value = settings.nickname;
			if (settings.channel) document.getElementById('channelInput').value = settings.channel;
			if (settings.autoReconnect !== undefined) document.getElementById('autoReconnect').checked = settings.autoReconnect;
		} catch (e) {
			writeToLog(`[WARN] 加载设置失败: ${e.message}`);
		}
	}

	function handleInputBlur() {
		if (inputBlurTimeoutId !== null) {
			clearTimeout(inputBlurTimeoutId);
		}
		inputBlurTimeoutId = setTimeout(() => {
			if (document.activeElement !== input && document.hasFocus()) {
				input.focus();
			}
		}, 100);
	}

	window.addEventListener("load", onLoad, false);

	function toggleHeaderMenu() {
		const menu = document.getElementById('headerMenuDropdown');
		if (menu) {
			menu.classList.toggle('visible');
			updateAutoReconnectMenuItem();
		}

		if (!menu.classList.contains('menu-attached')) {
			menu.classList.add('menu-attached');
			document.addEventListener('click', closeHeaderMenuOnClickOutside);
		}
	}

	function closeHeaderMenuOnClickOutside(event) {
		const menu = document.getElementById('headerMenuDropdown');
		const menuBtn = document.querySelector('.header-menu-btn');
		if (menu && !menu.contains(event.target) && !menuBtn.contains(event.target)) {
			menu.classList.remove('visible');
			menu.classList.remove('menu-attached');
			document.removeEventListener('click', closeHeaderMenuOnClickOutside);
		}
	}

	function toggleAutoReconnect() {
		const checkbox = document.getElementById('autoReconnect');
		if (checkbox) {
			checkbox.checked = !checkbox.checked;
			autoReconnect = checkbox.checked;
			updateAutoReconnectMenuItem();
			writeToLog(`[设置] 自动重连: ${autoReconnect ? '已启用' : '已禁用'}`);
			saveSettings();
		}
	}

	function updateAutoReconnectMenuItem() {
		const menuItems = document.querySelectorAll('.header-menu-item');
		const autoReconnectCheckbox = document.getElementById('autoReconnect');
		if (menuItems.length >= 3 && autoReconnectCheckbox) {
			const menuItem = menuItems[2];
			if (autoReconnectCheckbox.checked) {
				menuItem.classList.add('active');
			} else {
				menuItem.classList.remove('active');
			}
		}
	}

	function updateConnectionStatus(status) {
		const statusEl = document.getElementById('connectionStatus');
		const statusText = document.getElementById('statusText');
		if (!statusEl || !statusText) return;

		statusEl.classList.remove('connected', 'connecting', 'disconnected');

		if (status === 'connected') {
			statusEl.classList.add('connected');
			statusText.textContent = `已连接 (${nickname})`;
		} else if (status === 'connecting') {
			statusEl.classList.add('connecting');
			statusText.textContent = '连接中...';
		} else {
			statusEl.classList.add('disconnected');
			statusText.textContent = '未连接';
		}
	}

	function toggleLog() {
		const logContainer = document.getElementById('logContainer');
		if (logContainer) {
			logContainer.classList.toggle('visible');
			if (!logContainer.classList.contains('visible')) {
				logContainer.scrollTop = logContainer.scrollHeight;
			}
		}
	}

	function clearLog() {
		const logOutput = document.getElementById('logOutput');
		if (logOutput) {
			logOutput.textContent = '';
		}
	}

	function writeToLog(message) {
		const logOutput = document.getElementById('logOutput');
		const timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false });
		const fullMessage = `[${timestamp}] ${message}`;

		if (logOutput) {
			logOutput.textContent += fullMessage + '\n';
			logOutput.scrollTop = logOutput.scrollHeight;
		}

		console.log(fullMessage);
	}

	function showSSLWarning(url) {
		const warning = document.getElementById('sslWarning');
		const link = document.getElementById('sslLink');
		if (!warning || !link) return;

		let displayUrl = url || document.getElementById('wsUrl')?.value.trim();
		if (displayUrl) {
			link.href = displayUrl.replace('wss://', 'https://').replace('ws://', 'http://');
			link.textContent = link.href;
		} else {
			link.href = '#';
			link.textContent = '请先在WebSocket地址栏输入服务器地址';
		}
		warning.classList.add('visible');
		setTimeout(() => {
			if (warning) warning.classList.remove('visible');
		}, 6000);
	}

	function toggleConnection() {
		if (isConnected) {
			autoReconnect = false;
			updateAutoReconnectMenuItem();
			if (websocket) {
				try {
					if (window.connectTimeout) {
						clearTimeout(window.connectTimeout);
						window.connectTimeout = null;
					}
					websocket.close(1000, "User disconnected");
				} catch (e) {
					writeToLog(`[ERROR] 关闭WebSocket时出错: ${e.message}`);
				}
			}
		} else {
			doConnect();
		}
	}

	function validateNickname(nick) {
		if (!nick || nick.trim() === "") return false;
		return /^[a-zA-Z_\\`\[\]{}^|][a-zA-Z0-9_\\`\[\]{}^|-]*$/.test(nick);
	}

	function validateWsUrl(url) {
		if (!url) return false;
		return /^wss?:\/\/.+/.test(url);
	}

	function doConnect() {
		const wsUrlInput = document.getElementById('wsUrl');
		const nickInput = document.getElementById('nickInput');
		const channelInput = document.getElementById('channelInput');
		const reconnectCheckbox = document.getElementById('autoReconnect');
		const connectBtn = document.getElementById('connectBtn');

		if (!wsUrlInput || !nickInput || !channelInput || !connectBtn) {
			alert("界面元素加载错误, 请刷新页面重试");
			return;
		}

		wsUrl = wsUrlInput.value.trim();
		nickname = nickInput.value.trim();
		channelName = channelInput.value.trim();
		autoReconnect = reconnectCheckbox ? reconnectCheckbox.checked : false;

		if (!validateWsUrl(wsUrl)) {
			alert("WebSocket地址格式错误!必须以 ws:// 或 wss:// 开头");
			return;
		}
		if (!validateNickname(nickname)) {
			alert("昵称格式无效!必须以字母或特定符号开头, 不能包含空格和特殊字符");
			return;
		}
		if (channelName && !channelName.startsWith('#')) {
			channelName = '#' + channelName;
		}

		const originalChannelName = channelName;

		reconnectAttempts = 0;
		wsUrlInput.disabled = true;
		nickInput.disabled = true;
		channelInput.disabled = true;

		connectBtn.textContent = '连接中...';
		connectBtn.disabled = true;

		isDisconnecting = false;
		saveSettings();
		updateConnectionStatus('connecting');
		channels.innerHTML = '';
		channelContents.innerHTML = '';
		channelMap.clear();
		contentsWrapper.classList.remove('hidden');
		contentsWrapper.classList.add('visible');
		if (emptyState) emptyState.style.display = 'none';
		if (input) document.getElementById('inputContainer').style.display = 'flex';

		statusChannel = new Tab_Create("Status", "Status Window", false);
		writeToLog(`[系统] 正在连接: ${wsUrl}`);
		WebSocket_Connect(wsUrl);
	}

	function onDisconnect(reason = "") {

		if (isDisconnecting) {
			return;
		}
		isDisconnecting = true;

		stopKeepAlive();
		isConnected = false;
		const wsUrlInput = document.getElementById('wsUrl');
		const nickInput = document.getElementById('nickInput');
		const channelInput = document.getElementById('channelInput');
		const reconnectCheckbox = document.getElementById('autoReconnect');
		const connectBtn = document.getElementById('connectBtn');

		if (wsUrlInput) wsUrlInput.disabled = false;
		if (nickInput) nickInput.disabled = false;
		if (channelInput) channelInput.disabled = false;

		if (connectBtn) {
			connectBtn.textContent = '连接';
			connectBtn.disabled = false;
			connectBtn.classList.remove('disconnect');
		}

		updateConnectionStatus('disconnected');

		if (statusChannel) {
			Tab_Show("Status");
		}

		let disconnectMessage = "DISCONNECTED";
		let logMessage = "[系统] 已断开连接";

		if (reason === "user") {
			disconnectMessage = "用户主动断开连接";
			logMessage = "[系统] 用户主动断开连接";
		} else if (reason === "error") {
			disconnectMessage = "连接异常断开";
			logMessage = "[系统] 连接异常断开";
		}


		writeToScreen("var(--clr-font)", disconnectMessage, statusChannel, "");
		writeToLog(logMessage);

		if (autoReconnect && reconnectAttempts < maxReconnectAttempts) {
			reconnectAttempts++;
			const delay = reconnectDelay * reconnectAttempts;
			writeToLog(`[重连] ${Math.floor(delay / 1000)}秒后尝试第 ${reconnectAttempts}/${maxReconnectAttempts} 次重连...`);
			setTimeout(() => {
				if (!isConnected && autoReconnect) {
					writeToLog(`[重连] 正在尝试重新连接...`);
					doConnect();
				}
			}, delay);
		} else if (autoReconnect && reconnectAttempts >= maxReconnectAttempts) {
			writeToLog(`[重连] 达到最大重连次数, 停止尝试`);
			autoReconnect = false;
			updateAutoReconnectMenuItem();
			alert('自动重连失败, 请检查网络或服务器设置');
		}


		isDisconnecting = false;
	}

	function onKeyDown(e) {
		if (e && e.key === 'Enter') {
			send();
		} else if (e.key === 'Tab') {
			e.preventDefault();

			handleTabCompletion();
			return false;
		} else if (e.key === 'ArrowUp') {
			e.preventDefault();

			if (historyIndex > 0) {
				historyIndex--;
				input.value = messageHistory[historyIndex];
			}
			return false;
		} else if (e.key === 'ArrowDown') {
			e.preventDefault();

			if (historyIndex < messageHistory.length - 1) {
				historyIndex++;
				input.value = messageHistory[historyIndex];
			} else {
				historyIndex = messageHistory.length;
				input.value = "";
			}
			return false;
		}
	}

	function handleTabCompletion() {
		if (!input || !activeChannel || !activeChannel.users) return;
		const cursorPos = input.selectionStart;
		const text = input.value.substring(0, cursorPos);
		const words = text.split(' ');
		const lastWord = words[words.length - 1];

		if (!lastWord) return;

		const matches = activeChannel.users
			.filter(user => user[1].toLowerCase().startsWith(lastWord.toLowerCase()))
			.sort((a, b) => a[1].localeCompare(b[1]));

		if (matches.length === 1) {
			words[words.length - 1] = matches[0][1] + (words.length > 1 ? ' ' : ': ');
			input.value = words.join(' ') + input.value.substring(cursorPos);
			input.setSelectionRange(cursorPos + matches[0][1].length + (words.length > 1 ? 1 : 2), cursorPos + matches[0][1].length + (words.length > 1 ? 1 : 2));
		} else if (matches.length > 1) {
			writeToScreen("var(--clr-info)", `匹配: ${matches.map(m => m[1]).join(', ')}`, activeChannel, "*");
		}
	}

	function Tab_onClick(evt) {
		if (!evt || !evt.currentTarget) return;
		let chanName = evt.currentTarget.value;
		Tab_Show(chanName);
	}

	function Tabs_Hide() {
		let tabcontent = document.querySelectorAll(".channelcontent");
		tabcontent.forEach(content => content.classList.remove('active'));

		let tablinks = document.querySelectorAll(".channel");
		tablinks.forEach(link => link.classList.remove("active"));
	}

	function Tab_Show(name) {
		if (!name) return;
		let channel = channelMap.get(name);
		Tabs_Hide();
		if (channel && channel.channel) {
			channel.channel.classList.add('active');
			channel.button.classList.add("active");
			activeChannel = channel;

			clearUnreadBadge(channel);

			setTimeout(() => {
				if (channel.content) {
					channel.content.scrollTop = channel.content.scrollHeight;
				}
			}, 10);
		}
	}

	function addUnreadBadge(channel) {
		if (!channel || !channel.button) return;
		let badge = channel.button.querySelector('.unread-badge');
		if (!badge) {
			badge = document.createElement('span');
			badge.className = 'unread-badge';
			channel.button.appendChild(badge);
		}
		let count = parseInt(badge.textContent) || 0;
		badge.textContent = count + 1;
	}

	function clearUnreadBadge(channel) {
		if (!channel || !channel.button) return;
		const badge = channel.button.querySelector('.unread-badge');
		if (badge) badge.remove();
	}

	function HTML_escape(text) {
		if (!text) return "";
		let map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
		return text.replace(/[&<>"']/g, function (m) { return map[m]; });
	}

	function sortUserList(user_a, user_b) {
		if (!user_a || !user_b || user_a.length < 2 || user_b.length < 2) return 0;
		if (user_a[0][0] === user_b[0][0])
			return user_a[1].localeCompare(user_b[1], undefined, { sensitivity: 'accent' });
		if (!PrefixChars || !PrefixChars[1]) return 0;
		let aIndex = PrefixChars[1].indexOf(user_a[0][0]);
		let bIndex = PrefixChars[1].indexOf(user_b[0][0]);
		return aIndex - bIndex;
	}

	function Tab_Create(name, topic, createlist) {
		if (!name || !channels || !channelContents) {
			console.error("Tab_Create: 缺少必要元素");
			return;
		}
		Tabs_Hide();
		this.name = name;
		let escapedName = HTML_escape(name);

		this.button = document.createElement("button");
		this.button.innerHTML = escapedName;
		this.button.value = name;
		this.button.onclick = Tab_onClick;
		this.button.className = "channel";

		let x = document.createElement("button");
		x.innerHTML = "x";
		x.onclick = Tab_Close;
		x.value = name;
		x.className = "x";
		this.button.appendChild(x);

		channels.appendChild(this.button);

		this.channel = document.createElement("div");
		this.channel.className = "channelcontent";

		let navWrapper = document.createElement("nav");
		this.topic = document.createElement("h3");
		this.topic.innerHTML = HTML_escape(topic || "无主题");
		navWrapper.appendChild(this.topic);

		this.content = document.createElement("nav");
		navWrapper.appendChild(this.content);

		this.channel.appendChild(navWrapper);

		if (createlist) {
			this.userlist = document.createElement("ul");
			this.users = [];
			this.names_end = true;
			this.channel.appendChild(this.userlist);
		}

		channelContents.appendChild(this.channel);
		channelMap.set(name, this);
		activeChannel = this;
		Tab_Show(name);
		return this;
	}

	function Tab_Close(evt) {
		evt.stopPropagation();
		if (!evt || !evt.currentTarget) return;
		const channelName = evt.currentTarget.value;


		if (channelName === "Status") {
			writeToScreen("var(--clr-warning)", "Status频道是系统状态窗口, 不能关闭", statusChannel, "*");
			writeToLog("[警告] 尝试关闭Status频道(系统状态窗口, 不能关闭)");
			return;
		}


		if (isConnected && websocket && websocket.readyState === WebSocket.OPEN) {
			doSend("part " + channelName);
		} else {

			writeToLog(`[本地] 未连接状态, 直接关闭频道: ${channelName}`);
			Channel_Destroy(channelName);
		}
	}

	function Channel_Destroy(name) {
		if (!name) return;
		let channel = channelMap.get(name);
		if (!channel) return;
		channel.button.remove();
		channel.channel.remove();
		if (activeChannel == channel) {
			activeChannel = statusChannel;
		}
		channelMap.delete(name);
		if (activeChannel) {
			Tab_Show(activeChannel.name);
		}
	}

	function Channel_InsertUser(nick, channel, prefix) {
		if (!nick || !channel || !channel.userlist) return;
		let user = document.createElement("li");
		let tmp = document.createElement("p");

		if (prefix && prefix !== " ") {
			const prefixChar = prefix[0];
			const prefixInfo = DefaultPrefixMap[prefixChar];
			if (prefixInfo) {
				tmp.innerHTML = prefixInfo.symbol;
				tmp.style.color = prefixInfo.color;
				tmp.title = prefixInfo.name;
			} else {
				tmp.innerHTML = prefixChar;
			}
		}
		user.appendChild(tmp);

		tmp = document.createElement("p");
		tmp.innerHTML = HTML_escape(nick);
		user.appendChild(tmp);
		let i = 0;
		for (i; i < channel.users.length; i++) {
			if (channel.users[i] && channel.users[i][1]) {
				if (channel.users[i][1].localeCompare(nick, undefined, { sensitivity: 'accent' }) < 0) continue;
			}
			break;
		}
		channel.users.splice(i, 0, [prefix || " ", nick]);
		channel.userlist.insertBefore(user, channel.userlist.childNodes[i]);
	}

	function Channel_AppendUser(nick, channel, dontnotify, prefix) {
		if (!nick || !channel || !channel.userlist) return;
		let user = document.createElement("li");
		let tmp = document.createElement("p");
		if (prefix && prefix !== " ") {
			const prefixChar = prefix[0];
			const prefixInfo = DefaultPrefixMap[prefixChar];
			if (prefixInfo) {
				tmp.innerHTML = prefixInfo.symbol;
				tmp.style.color = prefixInfo.color;
				tmp.title = prefixInfo.name;
			} else {
				tmp.innerHTML = prefixChar;
			}
		}
		user.appendChild(tmp);

		tmp = document.createElement("p");
		tmp.innerHTML = HTML_escape(nick);
		user.appendChild(tmp);
		channel.userlist.appendChild(user);
	}

	function Channel_RemoveUser(nick, channel) {
		if (!nick || !channel || !channel.userlist) return;


		for (let i = 0; i < channel.users.length; i++) {
			if (channel.users[i] && channel.users[i][1] === nick) {

				for (let j = 0; j < channel.userlist.children.length; j++) {
					let userItem = channel.userlist.children[j];
					if (!userItem || !userItem.children[1]) continue;
					let anick = userItem.children[1].textContent;
					if (anick === nick) {
						userItem.remove();
						break;
					}
				}


				channel.users.splice(i, 1);
				return true;
			}
		}


		for (let i = 0; i < channel.userlist.children.length; i++) {
			let userItem = channel.userlist.children[i];
			if (!userItem || !userItem.children[1]) continue;
			let anick = userItem.children[1].textContent;
			if (anick === nick) {
				userItem.remove();
				return true;
			}
		}
	}

	function Channel_RenameUser(nick, newnick, channel) {
		if (!nick || !newnick || !channel) return;
		if (!channel.userlist) return;
		for (let i = 0; i < channel.users.length; i++) {
			if (channel.users[i] && channel.users[i][1] == nick) {
				let prefix = channel.users[i][0];
				Channel_RemoveUser(nick, channel);
				Channel_InsertUser(newnick, channel, prefix);
				return true;
			}
		}
	}

	function Channel_UpdateUserPrefix(nick, channel, add, prefix) {
		if (!nick || !channel || !channel.users || !PrefixChars) return;
		for (let i = 0; i < channel.users.length; i++) {
			if (channel.users[i] && channel.users[i][1] == nick) {
				let pos = PrefixChars[0].indexOf(prefix);
				if (pos < 0) return;
				let prefixes = "";
				if (add == "true" || add === true) {
					let ii;
					for (ii = 0; ii < channel.users[i][0].length; ii++) {
						if (PrefixChars[1].indexOf(channel.users[i][0][ii]) >= pos) break;
						prefixes += channel.users[i][0][ii];
					}
					prefixes += PrefixChars[1][pos];
					for (; ii < channel.users[i][0].length; ii++) {
						prefixes += channel.users[i][0][ii];
					}
				} else {
					let tmp = channel.users[i][0].indexOf(PrefixChars[1][pos]);
					if (tmp >= 0) {
						prefixes = channel.users[i][0].substring(0, tmp) + channel.users[i][0].substring(tmp + 1);
					}
				}
				if (prefixes == "") prefixes = " ";
				channel.users[i][0] = prefixes;
				Channel_RenameUser(nick, nick, channel);
				break;
			}
		}
	}

	function writeToScreen(color, message, channel, username) {
		if (!channel || !channel.content) return;
		let pre = document.createElement("p");
		pre.style.color = color;
		const now = new Date();
		const utcTime = now.toISOString().substr(11, 8);
		let displayMessage;
		if (username && username !== "") {
			displayMessage = `[${utcTime}] ${username}: ${linkify(message || "")}`;
		} else {
			displayMessage = `[${utcTime}] ${linkify(message || "")}`;
		}
		pre.innerHTML = displayMessage;
		let output = channel.content;
		if (output) {
			output.appendChild(pre);
			while (output.children.length > 200) {
				output.removeChild(output.children[0]);
			}

			requestAnimationFrame(() => {
				output.scrollTop = output.scrollHeight;
			});
		}
	}

	function linkify(text) {
		const urlRegex = /(https?:\/\/[^\s<>{}|\\^`[\]]+)/g;
		const mediaMaxWidth = '300px';

		return text.replace(urlRegex, function (url) {
			const lowerUrl = url.toLowerCase();
			const isImage = /\.(jpg|jpeg|png|gif|webp|bmp|svg)(\?.*)?$/i.test(lowerUrl);
			const isAudio = /\.(mp3|wav|ogg|aac|m4a|flac)(\?.*)?$/i.test(lowerUrl);
			const isVideo = /\.(mp4|webm|ogg|mov|avi|mkv|flv|m4v|m3u8)(\?.*)?$/i.test(lowerUrl);


			if (isImage) {
				return `<img src="${url}" alt="Image" style="max-width: ${mediaMaxWidth}; height: auto; border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">`;
			} else if (isAudio) {
				return `<audio controls src="${url}" style="max-width: ${mediaMaxWidth};"></audio>`;
			} else if (isVideo) {
				return `<video controls src="${url}" style="max-width: ${mediaMaxWidth}; height: auto; border-radius: 4px;"></video>`;
			} else {
				return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--clr-accent); text-decoration: underline; word-break: break-all;">${url}</a>`;
			}
		});
	}

	function send() {
		let text = input ? input.value.trim() : "";
		if (!text || !activeChannel) return;

		if (text[0] == "/") {
			if (text.indexOf("/me ") == 0) {
				const actionText = text.substring(4);
				const messages = splitIRCMessage("privmsg " + activeChannel.name + " :\x01ACTION " + actionText + "\x01");
				messages.forEach(msg => doSend(msg));
				writeToScreen("var(--clr-red)", `${nickname} ${actionText}`, activeChannel, "*");
			} else {
				writeToScreen("var(--clr-font)", text, statusChannel, "");
				const messages = splitIRCMessage(text.substring(1));
				messages.forEach(msg => doSend(msg));
			}
		} else {
			const messages = splitIRCMessage("privmsg " + activeChannel.name + " :" + text);
			messages.forEach((msg, index) => {
				doSend(msg);
				if (index === 0) {
					writeToScreen("var(--clr-font)", text, activeChannel, nickname);
				}
			});
		}

		if (text[0] != "/") {
			messageHistory.push(text);
			historyIndex = messageHistory.length;
		}
		if (input) input.value = "";
	}

	function splitIRCMessage(message) {
		const MAX_LENGTH = 450;
		if (message.length <= MAX_LENGTH) {
			return [message + "\n"];
		}

		const messages = [];
		let current = "";
		const words = message.split(' ');

		for (let i = 0; i < words.length; i++) {
			const word = words[i];
			const testLength = current.length + (current ? 1 : 0) + word.length;

			if (testLength <= MAX_LENGTH) {
				current += (current ? " " : "") + word;
			} else {
				if (current) {
					messages.push(current + "\n");
				}
				current = word;

				if (current.length > MAX_LENGTH) {
					const chunks = [];
					for (let j = 0; j < current.length; j += MAX_LENGTH) {
						chunks.push(current.substring(j, j + MAX_LENGTH));
					}
					messages.push(...chunks.map(chunk => chunk + "\n"));
					current = "";
				}
			}
		}

		if (current) {
			messages.push(current + "\n");
		}

		return messages;
	}

	function WebSocket_Connect(wsUri) {
		if (!wsUri) {
			writeToLog("[ERROR] WebSocket地址为空");
			return;
		}
		try {
			if (websocket) {
				try {
					websocket.onclose = null;
					websocket.onerror = null;
					websocket.onopen = null;
					websocket.onmessage = null;
					if (websocket.readyState !== WebSocket.CLOSED) {
						websocket.close(1000, "Reconnecting");
					}
				} catch (e) {
					writeToLog(`[WARN] 清理旧连接时出错: ${e.message}`);
				}
				websocket = null;
			}
			writeToLog(`[WebSocket] 正在创建连接: ${wsUri}`);
			websocket = new WebSocket(wsUri);
			websocket.binaryType = 'blob';


			if (window.connectTimeout) {
				clearTimeout(window.connectTimeout);
			}
			window.connectTimeout = setTimeout(() => {
				if (websocket && websocket.readyState === WebSocket.CONNECTING) {
					writeToLog(`[ERROR] 连接超时 (30秒)`);
					try {
						websocket.close(1006, "Connection timeout");
					} catch (e) {
						writeToLog(`[ERROR] 超时关闭连接失败: ${e.message}`);
					}
				}
			}, 30000);


			websocket.onclose = function handleOnClose(evt) {
				if (connectTimeout) clearTimeout(connectTimeout);
				onClose(evt);
			};
			websocket.onerror = function handleOnError(evt) {
				onError(evt);
			};
			websocket.onopen = function handleOnOpen(evt) {
				if (connectTimeout) clearTimeout(connectTimeout);
				onOpen(evt);
			};
			websocket.onmessage = function handleOnMessage(evt) {
				onMessage(evt);
			};
		} catch (e) {
			writeToLog(`[ERROR] WebSocket创建失败: ${e.message}`);
			onDisconnect();
			if (wsUrl && wsUrl.startsWith('wss://')) {
				showSSLWarning(wsUrl);
			}
			alert(`连接失败: ${e.message}\n\n如果是SSL证书错误, 请点击"SSL帮助"查看解决方案`);
		}
	}


	window.addEventListener('beforeunload', function cleanup() {
		stopKeepAlive();
		if (inputBlurTimeoutId !== null) {
			clearTimeout(inputBlurTimeoutId);
		}
		if (websocket) {
			websocket.onclose = null;
			websocket.onerror = null;
			websocket.onopen = null;
			websocket.onmessage = null;
			if (websocket.readyState === WebSocket.OPEN) {
				websocket.close(1000, "Page unload");
			}
		}
	});

	function onClose(evt) {

		if (!isConnected && isDisconnecting) {
			return;
		}

		isConnected = false;
		let reason = evt.reason || '连接关闭';
		let code = evt.code;


		let isUserDisconnect = false;

		if (isDisconnecting) {
			isUserDisconnect = true;
		} else if (code === 1000 && reason.includes("User disconnected")) {
			isUserDisconnect = true;
			reason = "用户主动断开连接";
		} else if (code === 1000) {
			reason = "正常关闭";
		}

		let logMsg = `[CLOSE] Code: ${code}`;

		switch (code) {
			case 1000: logMsg += isUserDisconnect ? ' (用户主动断开)' : ' (正常关闭)'; break;
			case 1001: logMsg += ' (终端离开)'; break;
			case 1002: logMsg += ' (协议错误)'; break;
			case 1003: logMsg += ' (数据类型错误)'; break;
			case 1005: logMsg += ' (无法获取状态码)'; break;
			case 1006: logMsg += ' (连接异常断开-可能由于网络问题)'; break;
			case 1011: logMsg += ' (服务器异常)'; break;
			case 1015: logMsg += ' (TLS握手失败)'; break;
			default: if (code >= 4000 && code <= 4999) { logMsg += ' (应用层错误)'; }
		}
		logMsg += ` - ${reason}`;

		writeToLog(logMsg);

		if (websocket) {

			websocket.onclose = null;
			websocket.onerror = null;
			websocket.onopen = null;
			websocket.onmessage = null;
			websocket = null;
		}


		let disconnectReason = "";
		if (isUserDisconnect) {
			disconnectReason = "user";
		} else if (code === 1006 || code >= 4000) {
			disconnectReason = "error";
		}
		onDisconnect(disconnectReason);
	}

	function onError(evt) {
		let errorType = 'WebSocket错误';
		if (evt && evt.target) {
			if (evt.target.readyState === WebSocket.CONNECTING) {
				errorType = '连接失败';
			} else if (evt.target.readyState === WebSocket.OPEN) {
				errorType = '消息错误';
			}
		}
		writeToScreen("var(--clr-red)", `ERROR: ${errorType}`, statusChannel, "");
		writeToLog(`[ERROR] ${errorType}: ${evt.data || '未知错误'}`);
		if (wsUrl && wsUrl.startsWith('wss://')) {
			showSSLWarning(wsUrl);
		}
	}

	function onOpen(evt) {
		isConnected = true;
		reconnectAttempts = 0;
		writeToScreen("var(--clr-font)", "CONNECTED", statusChannel, "");
		writeToLog(`[OPEN] WebSocket连接成功: ${wsUrl}`);
		updateConnectionStatus('connected');

		const connectBtn = document.getElementById('connectBtn');
		if (connectBtn) {
			connectBtn.textContent = '断开';
			connectBtn.disabled = false;
			connectBtn.classList.add('disconnect');
		}

		doSend("user websocket * * :WebSocket User");
		doSend("nick " + nickname);

		startKeepAlive();
	}

	function onMessage(evt) {
		if (!evt) return;
		const rawData = evt.data;
		writeToLog(`[Client]←[Server] ${typeof rawData === 'string' ? rawData : '[二进制数据]'}`);
		if (rawData instanceof Blob) {
			let fileReader = new FileReader();

			fileReader.addEventListener("loadend", function handleLoadEnd(event) {
				if (!event || !event.target) return;
				const fileReader = event.target;
				const raw = fileReader.result;
				writeToLog(`[Client]←[Server] (Blob→Text): ${raw}`);
				process(raw);

			});
			fileReader.readAsText(rawData);
		} else {
			process(rawData);
		}
	}

	function doSend(message) {
		if (!message) return;
		if (websocket && websocket.readyState === WebSocket.OPEN) {
			try {
				websocket.send(message);
				writeToLog(`[Client]→[Server] ${message.trim()}`);
			} catch (e) {
				writeToLog(`[ERROR] 发送消息失败: ${e.message}`);
				writeToScreen("var(--clr-red)", "发送失败: " + e.message, statusChannel, "");
			}
		} else {
			writeToLog(`[ERROR] WebSocket未连接, 无法发送: ${message.trim()}`);
			if (!isConnected) {
				writeToScreen("var(--clr-red)", "未连接, 消息未发送", statusChannel, "");
			}
		}
	}


	const DefaultPrefixMap = {
		'~': { symbol: '~', name: 'founder', color: 'var(--clr-purple)' },
		'&': { symbol: '&', name: 'admin', color: 'var(--clr-red)' },
		'%': { symbol: '%', name: 'halfop', color: 'var(--clr-green)' },
		'@': { symbol: '@', name: 'op', color: 'var(--clr-blue)' },
		'+': { symbol: '+', name: 'voice', color: 'var(--clr-gold)' }
	};

	var Commands = new Map();
	Commands.set("001", function (nick, data) {
		doSend("CAP REQ :multi-prefix");
		if (channelName) {
			doSend("join " + channelName);
			writeToLog(`[IRC] 接收001, 准备加入频道: ${channelName}`);
		} else {
			writeToLog(`[IRC] 接收001, 未设置自动加入频道`);
		}
	});
	Commands.set("005", function (nick, data) {
		if (!data || !PrefixChars) return;
		for (let i = 2; i < data.length; i++) {
			if (data[i].indexOf("PREFIX=") == 0) {
				let tmp = data[i].substring(8) + " ";
				if (tmp) {
					PrefixChars = tmp.split(")");
					writeToScreen("var(--clr-brown)", "PREFIX CHARS: " + PrefixChars[0] + " " + PrefixChars[1], statusChannel, "");
					writeToLog(`[IRC] 支持的PREFIX: ${PrefixChars[0]} ${PrefixChars[1]}`);
				}
			}
		}
	});
	Commands.set("332", function (nick, data) {
		if (!data || data.length < 5) return;
		let channel = channelMap.get(data[3]);
		if (!channel || !channel.topic) return;
		let text = data[4].substring(1);
		for (let i = 5; i < data.length; i++) {
			text += " " + data[i];
		}
		channel.topic.innerHTML = HTML_escape(text || "无主题");
		writeToLog(`[IRC] 频道主题: ${data[3]} - ${text}`);
	});
	Commands.set("353", function (nick, data) {
		if (!data || data.length < 6) return;
		let channel = channelMap.get(data[4]);
		if (!channel) return;
		if (channel.names_end == true) {
			channel.users = [];
			channel.names_end = false;
		}
		data[5] = data[5].substring(1);
		for (let i = 5; i < data.length; i++) {
			let prefix = "";
			let ii = 0;
			while (PrefixChars && PrefixChars[1] && PrefixChars[1].indexOf(data[i][ii]) >= 0) {
				prefix += data[i][ii];
				ii++;
			}
			if (prefix == "") prefix = " ";
			channel.users.push([prefix, data[i].substring(ii)]);
		}
		writeToLog(`[IRC] 接收用户列表: ${channel.users.length} 用户`);
	});
	Commands.set("366", function (nick, data) {
		if (!data || data.length < 4) return;
		let channel = channelMap.get(data[3]);
		if (!channel) return;
		channel.users.sort(sortUserList);
		channel.userlist.innerHTML = "";
		for (let i = 0; i < channel.users.length; i++) {
			Channel_AppendUser(channel.users[i][1], channel, true, channel.users[i][0]);
		}
		channel.names_end = true;
		writeToLog(`[IRC] 用户列表加载完成`);
	});
	Commands.set("432", function (nick, data) {
		nickname = prompt("错误: 昵称包含非法字符\n请输入新的昵称", "");
		if (nickname) {
			doSend("nick " + nickname);
			writeToLog(`[IRC] 昵称错误, 重新输入: ${nickname}`);
		}
	});
	Commands.set("433", function (nick, data) {
		nickname = prompt("错误: 昵称已被占用\n请输入新的昵称", "");
		if (nickname) {
			doSend("nick " + nickname);
			writeToLog(`[IRC] 昵称冲突, 新昵称: ${nickname}`);
		}
	});
	Commands.set("JOIN", function (nick, data) {
		if (!data || data.length < 3) return;
		if (data[0].indexOf(":" + nickname + "!") != 0) {
			if (data[2][0] == ":") data[2] = data[2].substring(1);
			let channel = channelMap.get(data[2]);
			if (!channel) return;
			Channel_InsertUser(nick, channel, " ");
			writeToScreen("var(--clr-green)", `${nick} 加入频道`, channel, "*");
		} else {
			const serverChannelName = data[2].substring(1);

			let channel = channelMap.get(serverChannelName);
			if (!channel) {
				for (let [key, value] of channelMap) {
					if (key.toLowerCase() === serverChannelName.toLowerCase()) {
						channel = value;
						break;
					}
				}
			}

			if (channel) {
				channel.name = serverChannelName;
				channel.button.innerHTML = HTML_escape(serverChannelName);
				channel.button.value = HTML_escape(serverChannelName);
				channel.button.querySelector('.x').value = HTML_escape(serverChannelName);
			} else {
				channel = new Tab_Create(serverChannelName, "", true);
			}

			channelName = serverChannelName;
			writeToScreen("var(--clr-green)", `你已加入频道 ${serverChannelName}`, channel, "*");
		}
		writeToLog(`[IRC] 用户加入: ${nick} → ${data[2]}`);
	});
	Commands.set("KICK", function (nick, data) {
		if (!data || data.length < 5) return;
		let channel = channelMap.get(data[2]);
		if (!channel) return;
		let text = data[4].substring(1);
		for (let i = 5; i < data.length; i++) {
			text += " " + data[i];
		}
		if (data[3] != nickname) {
			if (Channel_RemoveUser(data[3], channel)) {
				writeToScreen("var(--clr-red)", `${data[3]} 被 ${nick} 踢出 (原因: ${text})`, channel, "*");
			}
		} else {
			Channel_Destroy(data[2]);
			writeToScreen("var(--clr-red)", `你被 ${nick} 踢出 ${data[2]} (原因: ${text})`, statusChannel, "");
		}
		writeToLog(`[IRC] 被踢出: ${data[2]} by ${nick} - ${text}`);
	});
	Commands.set("MODE", function (nick, data) {
		if (!data || data.length < 4) return;
		let channel = channelMap.get(data[2]);
		if (!channel) return;
		let text = data[3];
		for (let i = 4; i < data.length; i++) {
			text += " " + data[i];
		}
		writeToScreen("var(--clr-blue)", `${nick} 设置模式: ${text}`, channel, "*");
		if (!PrefixChars || data[3].length < 1) return;
		let ii = 4;
		let status = "false";
		for (let i = 0; i < data[3].length; i++) {
			if (data[3][i] == "+") status = "true";
			else if (data[3][i] == "-") status = "false";
			else {
				if (ii < data.length) {
					Channel_UpdateUserPrefix(data[ii], channel, status, data[3][i]);
					ii++;
				}
			}
		}
		writeToLog(`[IRC] 模式变更: ${text}`);
	});
	Commands.set("NICK", function (nick, data) {
		if (!data || data.length < 3) return;
		let newnick = data[2].substring(1);
		if (nick == nickname) nickname = newnick;
		channelMap.forEach(function (channel, name) {
			if (Channel_RenameUser(nick, newnick, channel)) {
				if (newnick == nickname) {
					writeToScreen("var(--clr-green)", `你现在的新昵称是 ${newnick}`, channel, "*");
				} else {
					writeToScreen("var(--clr-green)", `${nick} 更名为 ${newnick}`, channel, "*");
				}
			}
		});
		writeToLog(`[IRC] 昵称变更: ${nick} → ${newnick}`);
	});
	Commands.set("PART", function (nick, data) {
		if (!data || data.length < 3) return;

		let channelName = data[2];
		if (channelName[0] == ":") channelName = channelName.substring(1);

		let channel = channelMap.get(channelName);
		if (!channel) {
			for (let [key, value] of channelMap) {
				if (key.toLowerCase() === channelName.toLowerCase()) {
					channel = value;
					break;
				}
			}
		}

		if (!channel) {
			writeToLog(`[警告] PART命令找不到频道: ${channelName}`);
			return;
		}

		if (data[0].indexOf(":" + nickname + "!") != 0) {
			if (Channel_RemoveUser(nick, channel)) {
				writeToScreen("var(--clr-green)", `${nick} 离开频道`, channel, "*");
			}
		} else {
			Channel_Destroy(channel.name);
			writeToScreen("var(--clr-green)", `你已离开频道 ${channel.name}`, statusChannel, "");
		}
		writeToLog(`[IRC] 离开频道: ${channelName}`);
	});
	Commands.set("TOPIC", function (nick, data) {
		if (!data || data.length < 4) return;
		let channel = channelMap.get(data[2]);
		if (!channel || !channel.topic) return;
		let text = data[3].substring(1);
		for (let i = 4; i < data.length; i++) {
			text += " " + data[i];
		}
		channel.topic.innerHTML = HTML_escape(text || "无主题");
		writeToScreen("var(--clr-blue)", `${nick} 设置主题为: ${text}`, channel, "*");
		writeToLog(`[IRC] 主题变更: ${data[2]} - ${text}`);
	});
	Commands.set("QUIT", function (nick, data) {
		channelMap.forEach(function (channel, name) {
			if (Channel_RemoveUser(nick, channel)) {
				writeToScreen("var(--clr-purple)", `${nick} 退出IRC`, channel, "*");
			}
		});
		writeToLog(`[IRC] 用户退出: ${nick}`);
	});
	Commands.set("PRIVMSG", function (nick, data) {
		if (!data || data.length < 4) return;
		let channel = channelMap.get(data[2]);
		if (!channel) channel = statusChannel;
		let text = data[3].substring(1);
		for (let i = 4; i < data.length; i++) {
			text += " " + data[i];
		}
		nick = data[0].substring(1).split("!")[0];
		if (text[0] == "\x01") {
			if (text.indexOf("\x01ACTION ") == 0) {
				writeToScreen("var(--clr-red)", `${nick} ${text.substring(8)}`, channel, "*");
			} else {
				writeToScreen("var(--clr-red)", `${nick} ${text}`, channel, "*");
			}
		} else {
			writeToScreen("var(--clr-font)", text, channel, nick);
			if (channel && channel !== activeChannel && channel !== statusChannel) {
				addUnreadBadge(channel);
			}
		}
	});
	Commands.set("NOTICE", function (nick, data) {
		if (!data || data.length < 4) return;
		let channel = channelMap.get(data[2]);
		if (!channel) channel = statusChannel;
		let text = data[3].substring(1);
		for (let i = 4; i < data.length; i++) {
			text += " " + data[i];
		}
		nick = data[0].substring(1).split("!")[0];
		writeToScreen("var(--clr-gold)", `通知 ${nick}: ${text}`, channel, "-");
		writeToLog(`[NOTICE] ${nick}: ${text}`);
	});

	function process(rawData) {
		if (!rawData) return;
		let data = rawData.split(" ");
		if (!data || data.length < 2) {
			return;
		}
		let nick = data[0].substring(1).split("!")[0];
		let command = data[1].toUpperCase();
		let fn = Commands.get(command);
		if (fn) {
			fn(nick, data);
			return;
		}
		if (!isNaN(parseInt(data[1]))) {
			let text = data[1];
			for (let i = 3; i < data.length; i++) {
				text += " " + data[i];
			}
			writeToScreen("var(--clr-gold)", text, statusChannel, "");
			writeToLog(`[SERVER] ${data[1]}: ${text}`);
			return;
		}
		if (data[0] == "PING") {
			let pongResponse = rawData.replace("PING", "PONG");
			writeToScreen("var(--clr-brown)", pongResponse, statusChannel, "");
			doSend(pongResponse);
			writeToLog(`[PING/PONG] ${pongResponse}`);
			return;
		}
		if (data[0] == "ERROR") {
			writeToScreen("var(--clr-font)", rawData, statusChannel, "");
			writeToLog(`[ERROR] ${rawData}`);
			return;
		}

	}

	function startKeepAlive() {
		stopKeepAlive();
		keepAliveTimer = setInterval(() => {
			if (isConnected && websocket && websocket.readyState === WebSocket.OPEN) {
				writeToLog("[KEEP-ALIVE] 发送 PING");
				doSend("PING keepalive");
			}
		}, keepAliveInterval);
	}

	function stopKeepAlive() {
		if (keepAliveTimer) {
			clearInterval(keepAliveTimer);
			keepAliveTimer = null;
		}
	}
</script>

</html>