<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<title>è‡ªé€‚åº”IRCå®¢æˆ·ç«¯</title>
	<style>
		/* CSSå˜é‡ - æ”¹è¿›çš„è‰²å½©ç³»ç»Ÿ */
		:root {
			--clr-background: #F8FAFC;
			--clr-background2: #E2E8F0;
			--clr-background3: #FFFFFF;
			--clr-background4: #CBD5E1;
			--clr-font: #0F172A;
			--clr-brown: #92400E;
			--clr-green: #047857;
			--clr-gold: #D97706;
			--clr-red: #DC2626;
			--clr-purple: #7C3AED;
			--clr-blue: #2563EB;
			--clr-accent: #4F46E5;
			--clr-border: #94A3B8;
			--clr-warning: #F59E0B;
			--clr-success: #10B981;
			--clr-highlight: #FEF3C7;
			--clr-unread: #EF4444;
			--shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
			--shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
			--shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
			--radius: 8px;
			--transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
		}

		/* æš—è‰²ä¸»é¢˜ - ä½¿ç”¨prefers-color-schemeå’Œæ‰‹åŠ¨åˆ‡æ¢ */
		@media (prefers-color-scheme: dark) {
			:root {
				--clr-background: #0F172A;
				--clr-background2: #1E293B;
				--clr-background3: #1E293B;
				--clr-background4: #334155;
				--clr-font: #F1F5F9;
				--clr-brown: #FDE68A;
				--clr-green: #6EE7B7;
				--clr-gold: #FBBF24;
				--clr-red: #FCA5A5;
				--clr-purple: #C4B5FD;
				--clr-blue: #93C5FD;
				--clr-accent: #818CF8;
				--clr-border: #475569;
				--clr-warning: #FCD34D;
				--clr-success: #6EE7B7;
				--clr-highlight: #78350F;
				--clr-unread: #F87171;
			}
		}

		[data-theme="dark"] {
			--clr-background: #0F172A !important;
			--clr-background2: #1E293B !important;
			--clr-background3: #1E293B !important;
			--clr-background4: #334155 !important;
			--clr-font: #F1F5F9 !important;
			--clr-brown: #FDE68A !important;
			--clr-green: #6EE7B7 !important;
			--clr-gold: #FBBF24 !important;
			--clr-red: #FCA5A5 !important;
			--clr-purple: #C4B5FD !important;
			--clr-blue: #93C5FD !important;
			--clr-accent: #818CF8 !important;
			--clr-border: #475569 !important;
			--clr-warning: #FCD34D !important;
			--clr-success: #6EE7B7 !important;
			--clr-highlight: #78350F !important;
			--clr-unread: #F87171 !important;
		}

		/* å…¨å±€é‡ç½®ä¸ä¼˜åŒ– */
		* {
			box-sizing: border-box;
			tap-highlight-color: transparent;
			-webkit-tap-highlight-color: transparent;
		}

		html,
		body {
			font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
			margin: 0;
			padding: 0;
			height: 100%;
			width: 100%;
			background-color: var(--clr-background);
			color: var(--clr-font);
			font-size: 14px;
			line-height: 1.6;
			overflow: hidden;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
			touch-action: manipulation;
		}

		/* ä¸»å®¹å™¨ - ä½¿ç”¨Gridå¸ƒå±€å®ç°å®Œç¾è‡ªé€‚åº” */
		.main {
			display: grid;
			grid-template-rows: auto 1fr;
			height: 100vh;
			width: 100%;
			position: relative;
		}

		/* å¤´éƒ¨ - å“åº”å¼Flexå¸ƒå±€ */
		.header {
			background: linear-gradient(90deg, var(--clr-background2), var(--clr-background));
			padding: 12px 20px;
			border-bottom: 1px solid var(--clr-border);
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 16px;
			flex-wrap: wrap;
		}

		.header h1 {
			margin: 0;
			font-size: clamp(16px, 4vw, 20px);
			font-weight: 700;
			color: var(--clr-accent);
			white-space: nowrap;
		}

		.header-controls {
			display: flex;
			gap: 8px;
			align-items: center;
			flex-wrap: wrap;
		}

		/* è®¾ç½®æ  - è‡ªé€‚åº”Gridå¸ƒå±€ */
		.settings-bar {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 8px;
			background-color: var(--clr-background2);
			border-bottom: 1px solid var(--clr-border);
			padding: 12px 16px;
			overflow-x: auto;
			max-height: 120px;
			overflow-y: auto;
		}

		.settings-group {
			display: flex;
			align-items: center;
			gap: 8px;
			min-width: 0;
		}

		.settings-group label {
			font-size: clamp(11px, 2vw, 13px);
			font-weight: 600;
			color: var(--clr-font);
			white-space: nowrap;
			flex-shrink: 0;
		}

		.settings-group input[type="text"] {
			flex: 1;
			padding: 6px 10px;
			background-color: var(--clr-background3);
			color: var(--clr-font);
			border: 1px solid var(--clr-border);
			border-radius: var(--radius);
			font-size: 13px;
			transition: var(--transition);
			min-width: 60px;
		}

		.settings-group input:focus {
			outline: none;
			border-color: var(--clr-accent);
			box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
		}

		.settings-group input[type="checkbox"] {
			width: 16px;
			height: 16px;
			cursor: pointer;
			flex-shrink: 0;
		}

		/* å“åº”å¼æŒ‰é’®ç»„ */
		.btn-group {
			display: flex;
			gap: 6px;
			flex-wrap: wrap;
		}

		.btn {
			padding: 6px 12px;
			background: linear-gradient(135deg, var(--clr-accent), var(--clr-purple));
			color: white;
			border: none;
			border-radius: var(--radius);
			cursor: pointer;
			font-weight: 600;
			font-size: 13px;
			white-space: nowrap;
			transition: var(--transition);
			user-select: none;
			-webkit-user-select: none;
		}

		.btn:hover {
			transform: translateY(-1px);
			box-shadow: var(--shadow-md);
		}

		.btn:disabled {
			background: var(--clr-background4);
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		.btn.disconnect {
			background: linear-gradient(135deg, var(--clr-red), #EF4444);
		}

		.btn-secondary {
			background: var(--clr-background4);
			color: var(--clr-font);
			border: 1px solid var(--clr-border);
		}

		.btn-secondary:hover {
			background: var(--clr-accent);
			color: white;
		}

		.btn-warning {
			background: linear-gradient(135deg, var(--clr-warning), #F59E0B);
			color: #000;
		}

		.btn-warning:hover {
			box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
		}

		/* è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ */
		.connection-status {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			padding: 4px 10px;
			background-color: var(--clr-background3);
			border: 1px solid var(--clr-border);
			border-radius: var(--radius);
			font-size: clamp(10px, 1.5vw, 11px);
			font-weight: 500;
			transition: var(--transition);
			margin-left: auto;
			white-space: nowrap;
		}

		.connection-status.connected {
			border-color: var(--clr-success);
			background-color: rgba(16, 185, 129, 0.1);
		}

		.connection-status.disconnected {
			border-color: var(--clr-red);
			background-color: rgba(220, 38, 38, 0.1);
		}

		.connection-status .indicator {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background-color: var(--clr-border);
			transition: background-color 0.3s;
		}

		.connection-status.connected .indicator {
			background-color: var(--clr-success);
			animation: pulse 2s infinite;
		}

		.connection-status.disconnected .indicator {
			background-color: var(--clr-red);
		}

		@keyframes pulse {
			0% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}

			100% {
				opacity: 1;
			}
		}

		/* SSLè­¦å‘Š - å“åº”å¼å®šä½ */
		.ssl-warning {
			display: none;
			position: fixed;
			bottom: 20px;
			right: 20px;
			max-width: min(380px, 90vw);
			background: linear-gradient(135deg, var(--clr-warning), #F59E0B);
			color: #000;
			padding: 12px 16px;
			border-radius: var(--radius);
			font-size: clamp(12px, 2vw, 13px);
			z-index: 200;
			box-shadow: var(--shadow-lg);
			backdrop-filter: blur(4px);
		}

		.ssl-warning.visible {
			display: block;
		}

		.ssl-warning a {
			color: #000;
			font-weight: 600;
			text-decoration: underline;
			cursor: pointer;
			word-break: break-all;
		}

		/* èŠå¤©å®¹å™¨ - ä½¿ç”¨Gridå®ç°å®Œç¾åˆ†å‰² */
		.chat-container {
			display: grid;
			grid-template-rows: auto 1fr auto;
			overflow: hidden;
			position: relative;
		}

		/* é¢‘é“æ ‡ç­¾æ  - å¯æ»šåŠ¨ */
		.channels {
			display: flex;
			align-items: center;
			padding: 8px 12px;
			gap: 6px;
			background-color: var(--clr-background2);
			border-bottom: 1px solid var(--clr-border);
			overflow-x: auto;
			overflow-y: hidden;
			scrollbar-width: thin;
			-webkit-overflow-scrolling: touch;
		}

		.channels::-webkit-scrollbar {
			height: 4px;
		}

		.channels::-webkit-scrollbar-thumb {
			background: var(--clr-accent);
			border-radius: 2px;
		}

		.channel {
			position: relative;
			padding: 6px 12px;
			background-color: var(--clr-background3);
			border: 1px solid var(--clr-border);
			border-radius: 20px;
			cursor: pointer;
			font-weight: 500;
			font-size: clamp(12px, 2vw, 13px);
			transition: var(--transition);
			display: flex;
			align-items: center;
			gap: 6px;
			white-space: nowrap;
			flex-shrink: 0;
			user-select: none;
		}

		.channel:hover {
			background-color: var(--clr-background4);
			transform: translateY(-1px);
		}

		.channel.active {
			background: linear-gradient(135deg, var(--clr-accent), var(--clr-purple));
			color: white;
			border-color: var(--clr-accent);
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
		}

		/* æœªè¯»æ¶ˆæ¯è®¡æ•° - ç»å¯¹å®šä½é¿å…é®æŒ¡ */
		.unread-count {
			background: var(--clr-unread);
			color: white;
			border-radius: 50%;
			min-width: 18px;
			height: 18px;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			font-size: 10px;
			font-weight: bold;
			position: absolute;
			top: -6px;
			right: -6px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
			animation: bounce 0.3s ease;
		}

		@keyframes bounce {

			0%,
			100% {
				transform: scale(1);
			}

			50% {
				transform: scale(1.2);
			}
		}

		.channel button.x {
			background: none;
			border: none;
			color: inherit;
			cursor: pointer;
			padding: 2px 6px;
			font-weight: bold;
			border-radius: 50%;
			font-size: 14px;
			transition: var(--transition);
			margin-left: 2px;
		}

		.channel button.x:hover {
			background-color: rgba(255, 255, 255, 0.2);
			transform: scale(1.1);
		}

		/* æ—¥å¿—å®¹å™¨ */
		.log-container {
			position: absolute;
			inset: 0;
			background-color: var(--clr-background3);
			border-bottom: 2px solid var(--clr-accent);
			display: none;
			flex-direction: column;
			z-index: 100;
			box-shadow: var(--shadow-lg);
		}

		.log-container.visible {
			display: flex;
		}

		.log-header {
			flex: 0 0 35px;
			padding: 0 15px;
			background-color: var(--clr-background2);
			border-bottom: 1px solid var(--clr-border);
			display: flex;
			justify-content: space-between;
			align-items: center;
			font-weight: 600;
			font-size: clamp(12px, 2vw, 13px);
		}

		.log-controls {
			display: flex;
			gap: 8px;
		}

		.log-controls button {
			padding: 4px 10px;
			background-color: var(--clr-background4);
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 11px;
			transition: var(--transition);
		}

		.log-controls button:hover {
			background-color: var(--clr-accent);
			color: white;
		}

		#logOutput {
			flex: 1 1 auto;
			overflow-y: auto;
			padding: 10px;
			font-size: 11px;
			font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
			background-color: var(--clr-background3);
			color: var(--clr-font);
			white-space: pre-wrap;
			word-wrap: break-word;
			line-height: 1.5;
		}

		/* é¢‘é“å†…å®¹åŒºåŸŸ - ä½¿ç”¨CSS Grid */
		.channelcontents {
			display: flex;
			overflow: hidden;
			padding: 12px;
			gap: 12px;
		}

		.channelcontent {
			display: grid;
			grid-template-columns: 1fr auto;
			width: 100%;
			height: 100%;
			gap: 12px;
		}

		.channelcontent nav {
			display: flex;
			flex-direction: column;
			background-color: var(--clr-background3);
			border-radius: var(--radius);
			overflow: hidden;
			border: 1px solid var(--clr-border);
			box-shadow: var(--shadow-sm);
		}

		.channelcontent nav h3 {
			flex: 0 0 auto;
			padding: 10px 15px;
			margin: 0;
			background-color: var(--clr-background2);
			border-bottom: 1px solid var(--clr-border);
			font-weight: 600;
			font-size: clamp(13px, 2vw, 14px);
			position: sticky;
			top: 0;
			z-index: 1;
		}

		.channelcontent nav nav {
			flex: 1 1 auto;
			overflow-y: auto;
			padding: 15px;
			scrollbar-width: thin;
		}

		.channelcontent nav nav::-webkit-scrollbar {
			width: 6px;
		}

		.channelcontent nav nav::-webkit-scrollbar-thumb {
			background: var(--clr-accent);
			border-radius: 3px;
		}

		.channelcontent nav p {
			margin: 0;
			padding: 3px 0;
			word-wrap: break-word;
			overflow-wrap: anywhere;
		}

		/* æåŠé«˜äº® */
		.mention-highlight {
			background: var(--clr-highlight);
			font-weight: 600;
			padding: 1px 4px;
			border-radius: 4px;
			color: var(--clr-font);
		}

		/* ç”¨æˆ·åˆ—è¡¨ - å¯æŠ˜å  */
		ul {
			flex: 0 0 200px;
			overflow-y: auto;
			overflow-x: hidden;
			padding: 10px;
			margin: 0;
			border-left: 1px solid var(--clr-border);
			list-style: none;
			background-color: var(--clr-background3);
			border-radius: 0 var(--radius) var(--radius) 0;
			scrollbar-width: thin;
		}

		ul.collapsed {
			flex: 0 0 0;
			padding: 0;
			border: none;
			overflow: hidden;
		}

		.channelcontents li {
			padding: 6px 10px;
			margin: 1px 0;
			display: flex;
			gap: 8px;
			border-radius: 4px;
			cursor: pointer;
			transition: var(--transition);
			align-items: center;
		}

		.channelcontents li:hover {
			background-color: var(--clr-background2);
		}

		.channelcontents li p {
			margin: 0;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.channelcontents li p:first-child {
			width: 20px;
			color: var(--clr-purple);
			font-weight: bold;
			text-align: center;
			flex-shrink: 0;
		}

		.channelcontents li p:nth-child(2) {
			flex: 1;
			color: var(--clr-green);
		}

		/* ç”¨æˆ·ä¸Šä¸‹æ–‡èœå• */
		.user-context-menu {
			position: absolute;
			background: var(--clr-background3);
			border: 1px solid var(--clr-border);
			border-radius: var(--radius);
			padding: 4px;
			display: none;
			z-index: 100;
			box-shadow: var(--shadow-lg);
			min-width: 150px;
			backdrop-filter: blur(4px);
		}

		.user-context-menu.visible {
			display: block;
		}

		.context-menu-item {
			padding: 8px 12px;
			cursor: pointer;
			border-radius: 4px;
			font-size: 13px;
			transition: var(--transition);
		}

		.context-menu-item:hover {
			background: var(--clr-accent);
			color: white;
		}

		/* è¾“å…¥æ¡†å®¹å™¨ */
		.input-container {
			position: relative;
			padding: 12px;
			background-color: var(--clr-background2);
			border-top: 1px solid var(--clr-border);
		}

		#input {
			width: 100%;
			padding: 12px 15px;
			background-color: var(--clr-background3);
			color: var(--clr-font);
			border: 1px solid var(--clr-border);
			border-radius: var(--radius);
			font-size: 14px;
			transition: var(--transition);
			outline: none;
		}

		#input:focus {
			border-color: var(--clr-accent);
			box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
		}

		/* è‡ªåŠ¨è¡¥å…¨å»ºè®® */
		.autocomplete-suggestions {
			position: absolute;
			background: var(--clr-background3);
			border: 1px solid var(--clr-border);
			border-radius: var(--radius);
			max-height: 200px;
			overflow-y: auto;
			display: none;
			z-index: 50;
			box-shadow: var(--shadow-lg);
			width: calc(100% - 24px);
			bottom: 60px;
		}

		.autocomplete-suggestions.visible {
			display: block;
		}

		.autocomplete-item {
			padding: 8px 12px;
			cursor: pointer;
			font-size: 13px;
			transition: var(--transition);
		}

		.autocomplete-item:hover,
		.autocomplete-item.active {
			background: var(--clr-accent);
			color: white;
		}

		/* é“¾æ¥é¢„è§ˆ */
		.link-preview {
			position: absolute;
			background: var(--clr-background3);
			border: 1px solid var(--clr-border);
			border-radius: var(--radius);
			padding: 8px;
			display: none;
			z-index: 101;
			box-shadow: var(--shadow-lg);
			max-width: min(300px, 90vw);
			font-size: 12px;
			color: var(--clr-font);
			word-break: break-all;
			backdrop-filter: blur(4px);
		}

		.link-preview.visible {
			display: block;
		}

		/* æœç´¢å®¹å™¨ - å“åº”å¼ */
		.search-container {
			position: relative;
			grid-column: span 1;
		}

		.search-container input {
			width: 100%;
		}

		.search-results {
			position: absolute;
			top: 100%;
			right: 0;
			background: var(--clr-background3);
			border: 1px solid var(--clr-border);
			border-radius: var(--radius);
			padding: 8px;
			margin-top: 4px;
			min-width: min(250px, 90vw);
			display: none;
			z-index: 1000;
			box-shadow: var(--shadow-lg);
			max-height: 300px;
			overflow-y: auto;
			backdrop-filter: blur(4px);
		}

		.search-results.visible {
			display: block;
		}

		.search-result-item {
			padding: 6px;
			cursor: pointer;
			border-radius: 4px;
			margin: 2px 0;
			font-size: 12px;
			transition: var(--transition);
		}

		.search-result-item:hover {
			background: var(--clr-background4);
		}

		/* æŠ˜å æŒ‰é’® */
		.toggle-users-btn {
			position: absolute;
			top: 10px;
			right: 10px;
			padding: 4px 8px;
			background: var(--clr-accent);
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
			z-index: 2;
		}

		/* å“åº”å¼æ–­ç‚¹ - ç§»åŠ¨ä¼˜å…ˆ */

		/* æå°å±å¹• (320px - 480px) */
		@media (max-width: 480px) {
			:root {
				--radius: 6px;
			}

			.header {
				padding: 10px 12px;
				gap: 8px;
			}

			.header h1 {
				font-size: 16px;
			}

			.settings-bar {
				grid-template-columns: 1fr;
				padding: 8px 12px;
				gap: 6px;
				max-height: 150px;
			}

			.settings-group {
				flex-direction: column;
				align-items: flex-start;
				gap: 4px;
			}

			.settings-group input[type="text"] {
				width: 100%;
			}

			.btn-group {
				flex-direction: column;
				width: 100%;
			}

			.btn {
				width: 100%;
			}

			.connection-status {
				margin-left: 0;
				justify-content: center;
				width: 100%;
			}

			.channels {
				padding: 6px 8px;
			}

			.channel {
				padding: 6px 10px;
				font-size: 12px;
			}

			.channelcontent {
				grid-template-columns: 1fr;
			}

			ul {
				display: none;
			}

			.channelcontents {
				padding: 8px;
			}

			.channelcontent nav nav {
				padding: 10px;
			}

			#input {
				font-size: 16px;
				/* é˜²æ­¢iOSç¼©æ”¾ */
			}

			.input-container {
				padding: 8px;
			}
		}

		/* å°å±å¹• (481px - 768px) */
		@media (min-width: 481px) and (max-width: 768px) {
			.settings-bar {
				grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
			}

			.channelcontent {
				grid-template-columns: 1fr auto;
			}

			ul {
				flex: 0 0 160px;
			}

			.channels {
				padding: 8px 10px;
			}
		}

		/* ä¸­ç­‰å±å¹• (769px - 1024px) */
		@media (min-width: 769px) and (max-width: 1024px) {
			.settings-bar {
				grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
			}

			ul {
				flex: 0 0 180px;
			}
		}

		/* å¤§å±å¹• (>1024px) */
		@media (min-width: 1025px) {
			.settings-bar {
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			}

			ul {
				flex: 0 0 220px;
			}
		}

		/* é«˜DPIå±å¹•ä¼˜åŒ– */
		@media (-webkit-min-device-pixel-ratio: 2),
		(min-resolution: 192dpi) {
			body {
				font-weight: 400;
			}

			.channel button.x {
				padding: 4px 8px;
			}
		}

		/* æ¨ªå±æ¨¡å¼ä¼˜åŒ– */
		@media (orientation: landscape) and (max-height: 500px) {
			.header {
				padding: 8px 12px;
			}

			.settings-bar {
				padding: 6px 12px;
				max-height: 80px;
			}
		}

		/* è§¦æ‘¸ä¼˜åŒ– */
		@media (hover: none) {

			.channel:hover,
			.context-menu-item:hover {
				background: none;
			}

			.channel:active {
				background: var(--clr-background4);
			}

			.context-menu-item:active {
				background: var(--clr-accent);
				color: white;
			}
		}

		/* æ‰“å°æ ·å¼ */
		@media print {

			.settings-bar,
			.ssl-warning,
			.user-context-menu,
			.autocomplete-suggestions,
			.search-container {
				display: none !important;
			}

			.main {
				grid-template-rows: 1fr;
			}

			body {
				background: white !important;
				color: black !important;
			}
		}

		/* åŠ¨ç”»ä¼˜åŒ– */
		@media (prefers-reduced-motion: reduce) {
			* {
				transition: none !important;
				animation: none !important;
			}
		}
	</style>
</head>

<body>
	<div class="main">
		<div class="header">
			<h1 id="caption">è‡ªé€‚åº”IRCå®¢æˆ·ç«¯</h1>
			<div class="header-controls">
				<button class="btn btn-warning" onclick="toggleTheme()" title="åˆ‡æ¢æ˜æš—ä¸»é¢˜">ğŸŒ“ ä¸»é¢˜</button>
				<div class="connection-status disconnected" id="connectionStatus">
					<span class="indicator"></span>
					<span id="statusText">æœªè¿æ¥</span>
				</div>
			</div>
		</div>

		<div class="settings-bar">
			<div class="settings-group">
				<label>WebSocket:</label>
				<input type="text" id="wsUrl" value="" placeholder="wss://irc.example.com:port/">
			</div>
			<div class="settings-group">
				<label>æ˜µç§°:</label>
				<input type="text" id="nickInput" value="" placeholder="è¾“å…¥æ˜µç§°">
			</div>
			<div class="settings-group">
				<label>é¢‘é“:</label>
				<input type="text" id="channelInput" value="" placeholder="#channel">
			</div>
			<div class="search-container">
				<input type="text" id="searchInput" placeholder="ğŸ” æœç´¢æ¶ˆæ¯..." onkeyup="onSearchKeyUp(event)">
				<div class="search-results" id="searchResults"></div>
			</div>
			<div class="settings-group">
				<label title="å¯ç”¨åä¼šåœ¨æ–­å¼€æ—¶è‡ªåŠ¨é‡è¿">
					<input type="checkbox" id="autoReconnect"> è‡ªåŠ¨é‡è¿
				</label>
			</div>
			<div class="settings-group">
				<label title="æ¡Œé¢é€šçŸ¥">
					<input type="checkbox" id="enableNotifications"> æ¡Œé¢é€šçŸ¥
				</label>
			</div>
			<div class="btn-group">
				<button class="btn btn-warning" onclick="showSSLWarning()" title="SSLè¯ä¹¦é—®é¢˜å¸®åŠ©">ğŸ”’ SSLå¸®åŠ©</button>
				<button class="btn" id="connectBtn" onclick="toggleConnection()">è¿æ¥</button>
				<button class="btn btn-secondary" onclick="toggleLog()">ğŸ“‹ æ—¥å¿—</button>
			</div>
		</div>

		<div class="ssl-warning" id="sslWarning">
			<strong>âš ï¸ æµè§ˆå™¨æ— æ³•å¿½ç•¥SSLè¯ä¹¦é”™è¯¯!</strong><br>
			1. æ”¹ç”¨ <code>ws://</code> éåŠ å¯†è¿æ¥<br>
			2. è®¿é—® <a id="sslLink" target="_blank">æœåŠ¡å™¨URL</a> å¹¶æ‰‹åŠ¨ä¿¡ä»»è¯ä¹¦
		</div>

		<div class="log-container" id="logContainer">
			<div class="log-header">
				<span>WebSocketæ—¥å¿—</span>
				<div class="log-controls">
					<button onclick="clearLog()">æ¸…ç©º</button>
					<button onclick="toggleLog()">å…³é—­</button>
				</div>
			</div>
			<div id="logOutput"></div>
		</div>

		<div class="chat-container">
			<div class="channels" style="display: none;"></div>
			<nav class="channelcontents" style="display: none;">
				<div class="channelcontent">
					<nav>
						<h3></h3>
						<nav></nav>
					</nav>
					<ul></ul>
				</div>
			</nav>
			<div class="input-container" style="display: none;">
				<input type="text" id="input" onKeyPress="onKeyPress(event)" onKeyDown="onKeyDown(event)"
					   onInput="onInputChanged(event)" placeholder="è¾“å…¥æ¶ˆæ¯ (Tabè¡¥å…¨, â†‘â†“å†å²)" autocomplete="off" />
				<div class="autocomplete-suggestions" id="autocompleteSuggestions"></div>
			</div>
		</div>

		<div class="user-context-menu" id="userContextMenu"></div>
		<div class="link-preview" id="linkPreview"></div>
	</div>

	<script>
		// æ ¸å¿ƒå˜é‡ä¸é…ç½®
		var nickname = "", channelName = "", wsUrl = "";
		var channels, channelContents, input;
		var channelMap = new Map();
		var activeChannel = null, statusChannel = null;
		var PrefixChars, websocket = null, isConnected = false;
		var autoReconnect = false, reconnectAttempts = 0;
		var maxReconnectAttempts = 5, reconnectDelay = 3000;
		var ignoredUsers = new Set();
		var commandHistory = [], commandIndex = -1;
		var touchStartX = 0, touchStartY = 0;

		// åˆå§‹åŒ–
		function onLoad() {
			channels = document.querySelector('.channels');
			channelContents = document.querySelector('.channelcontents');
			input = document.getElementById('input');

			let url = new URL(document.location);
			if (url.hash) document.getElementById('channelInput').value = url.hash;

			if (window.frameElement) document.getElementById("caption").style.display = "none";

			updateConnectionStatus(false);
			setupEventListeners();
			requestNotificationPermission();
			applySavedTheme();
		}
		window.addEventListener("load", onLoad);

		// äº‹ä»¶ç›‘å¬å™¨è®¾ç½®
		function setupEventListeners() {
			// ç‚¹å‡»å¤–éƒ¨å…³é—­èœå•
			document.addEventListener('click', function (e) {
				const contextMenu = document.getElementById('userContextMenu');
				const searchResults = document.getElementById('searchResults');
				if (contextMenu && !contextMenu.contains(e.target)) {
					contextMenu.classList.remove('visible');
				}
				if (searchResults && !searchResults.contains(e.target) && e.target !== document.getElementById('searchInput')) {
					searchResults.classList.remove('visible');
				}
			});

			// è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒ
			let startX = 0, startY = 0;
			document.addEventListener('touchstart', function (e) {
				startX = e.touches[0].clientX;
				startY = e.touches[0].clientY;
			}, { passive: true });

			document.addEventListener('touchend', function (e) {
				if (!startX || !startY) return;
				const endX = e.changedTouches[0].clientX;
				const endY = e.changedTouches[0].clientY;
				const diffX = startX - endX;
				const diffY = startY - endY;

				// æ°´å¹³æ»‘åŠ¨åˆ‡æ¢é¢‘é“
				if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
					const tabs = Array.from(document.getElementsByClassName('channel'));
					const activeIndex = tabs.findIndex(t => t.classList.contains('active'));
					if (diffX > 0 && activeIndex < tabs.length - 1) {
						tabs[activeIndex + 1].click(); // æ»‘åŠ¨åˆ°ä¸‹ä¸€ä¸ª
					} else if (diffX < 0 && activeIndex > 0) {
						tabs[activeIndex - 1].click(); // æ»‘åŠ¨åˆ°ä¸Šä¸€ä¸ª
					}
				}
				startX = startY = 0;
			});

			// çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¡ç®—å¸ƒå±€
			window.addEventListener('resize', function () {
				setTimeout(() => {
					if (activeChannel && activeChannel.content) {
						activeChannel.content.scrollTop = activeChannel.content.scrollHeight;
					}
				}, 100);
			});
		}

		// ä¸»é¢˜ç®¡ç†
		function applySavedTheme() {
			const savedTheme = localStorage.getItem('irc-theme');
			if (savedTheme === 'dark') {
				document.documentElement.setAttribute('data-theme', 'dark');
			}
		}

		function toggleTheme() {
			const currentTheme = document.documentElement.getAttribute('data-theme');
			if (currentTheme === 'dark') {
				document.documentElement.removeAttribute('data-theme');
				localStorage.setItem('irc-theme', 'light');
			} else {
				document.documentElement.setAttribute('data-theme', 'dark');
				localStorage.setItem('irc-theme', 'dark');
			}
		}

		// é€šçŸ¥æƒé™
		function requestNotificationPermission() {
			if ('Notification' in window && Notification.permission === 'default') {
				Notification.requestPermission().then(permission => {
					if (permission === 'granted') {
						document.getElementById('enableNotifications').checked = true;
					}
				});
			}
		}

		// è¿æ¥çŠ¶æ€æ›´æ–°
		function updateConnectionStatus(connected) {
			const statusEl = document.getElementById('connectionStatus');
			const statusText = document.getElementById('statusText');
			if (!statusEl || !statusText) return;

			if (connected) {
				statusEl.classList.remove('disconnected');
				statusEl.classList.add('connected');
				statusText.textContent = `å·²è¿æ¥ (${nickname})`;
			} else {
				statusEl.classList.remove('connected');
				statusEl.classList.add('disconnected');
				statusText.textContent = 'æœªè¿æ¥';
			}
		}

		// æ—¥å¿—åŠŸèƒ½
		function toggleLog() {
			const logContainer = document.getElementById('logContainer');
			if (logContainer) {
				logContainer.classList.toggle('visible');
				if (logContainer.classList.contains('visible')) {
					document.body.style.overflow = 'hidden';
				} else {
					document.body.style.overflow = '';
				}
			}
		}

		function clearLog() {
			const logOutput = document.getElementById('logOutput');
			if (logOutput) logOutput.textContent = '';
		}

		function writeToLog(message) {
			const logOutput = document.getElementById('logOutput');
			if (logOutput) {
				const timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false });
				logOutput.textContent += `[${timestamp}] ${message}\n`;
				logOutput.scrollTop = logOutput.scrollHeight;
			}
		}

		function showSSLWarning(url) {
			const warning = document.getElementById('sslWarning');
			const link = document.getElementById('sslLink');
			if (!warning || !link) return;

			let displayUrl = url || document.getElementById('wsUrl')?.value.trim();
			if (displayUrl) {
				link.href = displayUrl.replace('wss://', 'https://').replace('ws://', 'http://');
				link.textContent = link.href;
			} else {
				link.href = '#';
				link.textContent = 'è¯·å…ˆè¾“å…¥æœåŠ¡å™¨åœ°å€';
			}
			warning.classList.add('visible');
			setTimeout(() => warning.classList.remove('visible'), 5000);
		}

		// è¿æ¥ç®¡ç†
		function toggleConnection() {
			if (isConnected) {
				autoReconnect = false;
				document.getElementById('autoReconnect').checked = false;
				if (websocket) {
					try { websocket.close(1000, "User disconnected"); } catch (e) { }
				}
				onDisconnect();
			} else {
				doConnect();
			}
		}

		function validateNickname(nick) {
			return nick && /^[a-zA-Z_\\`\[\]{}^|][a-zA-Z0-9_\\`\[\]{}^|-]*$/.test(nick);
		}

		function validateWsUrl(url) {
			return url && /^wss?:\/\/.+/.test(url);
		}

		function doConnect() {
			const wsUrlInput = document.getElementById('wsUrl');
			const nickInput = document.getElementById('nickInput');
			const channelInput = document.getElementById('channelInput');
			const reconnectCheckbox = document.getElementById('autoReconnect');
			const connectBtn = document.getElementById('connectBtn');

			if (!wsUrlInput || !nickInput || !channelInput || !connectBtn) {
				alert("ç•Œé¢å…ƒç´ åŠ è½½é”™è¯¯, è¯·åˆ·æ–°é¡µé¢é‡è¯•");
				return;
			}

			wsUrl = wsUrlInput.value.trim();
			nickname = nickInput.value.trim();
			channelName = channelInput.value.trim();
			autoReconnect = reconnectCheckbox?.checked || false;

			if (!validateWsUrl(wsUrl)) {
				alert("WebSocketåœ°å€æ ¼å¼é”™è¯¯!å¿…é¡»ä»¥ ws:// æˆ– wss:// å¼€å¤´");
				return;
			}
			if (!validateNickname(nickname)) {
				alert("æ˜µç§°æ ¼å¼æ— æ•ˆ!å¿…é¡»ä»¥å­—æ¯æˆ–ç‰¹å®šç¬¦å·å¼€å¤´, ä¸èƒ½åŒ…å«ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦");
				return;
			}
			if (channelName && !channelName.startsWith('#')) {
				channelName = '#' + channelName;
			}

			reconnectAttempts = 0;
			wsUrlInput.disabled = true;
			nickInput.disabled = true;
			channelInput.disabled = true;
			if (reconnectCheckbox) reconnectCheckbox.disabled = true;
			connectBtn.textContent = 'è¿æ¥ä¸­...';
			connectBtn.disabled = true;

			channels.innerHTML = '';
			channelContents.innerHTML = '';
			channelMap.clear();
			statusChannel = new Tab_Create("Status", "Status Window", false);
			statusChannel.unreadCount = 0;

			writeToLog(`[ç³»ç»Ÿ] æ­£åœ¨è¿æ¥: ${wsUrl}`);
			WebSocket_Connect(wsUrl);
		}

		function onDisconnect() {
			isConnected = false;
			const elements = {
				wsUrl: document.getElementById('wsUrl'),
				nickInput: document.getElementById('nickInput'),
				channelInput: document.getElementById('channelInput'),
				reconnectCheckbox: document.getElementById('autoReconnect'),
				connectBtn: document.getElementById('connectBtn'),
				channels: document.querySelector('.channels'),
				channelContents: document.querySelector('.channelcontents'),
				input: document.getElementById('input')
			};

			Object.entries(elements).forEach(([key, el]) => {
				if (!el) return;
				switch (key) {
					case 'connectBtn':
						el.textContent = 'è¿æ¥';
						el.disabled = false;
						el.classList.remove('disconnect');
						break;
					case 'channels':
					case 'channelContents':
						el.style.display = 'none';
						break;
					case 'input':
						el.style.display = 'none';
						el.value = '';
						break;
					default:
						el.disabled = false;
				}
			});

			updateConnectionStatus(false);
			writeToScreen("var(--clr-font)", "DISCONNECTED", statusChannel, "");
			writeToLog(`[ç³»ç»Ÿ] å·²æ–­å¼€è¿æ¥`);

			if (autoReconnect && reconnectAttempts < maxReconnectAttempts) {
				reconnectAttempts++;
				const delay = reconnectDelay * reconnectAttempts;
				writeToLog(`[é‡è¿] ${Math.floor(delay / 1000)}ç§’åå°è¯•ç¬¬ ${reconnectAttempts}/${maxReconnectAttempts} æ¬¡é‡è¿...`);
				setTimeout(() => {
					if (!isConnected && autoReconnect) {
						writeToLog(`[é‡è¿] æ­£åœ¨å°è¯•é‡æ–°è¿æ¥...`);
						doConnect();
					}
				}, delay);
			} else if (autoReconnect && reconnectAttempts >= maxReconnectAttempts) {
				writeToLog(`[é‡è¿] è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°, åœæ­¢å°è¯•`);
				autoReconnect = false;
				document.getElementById('autoReconnect').checked = false;
				alert('è‡ªåŠ¨é‡è¿å¤±è´¥, è¯·æ£€æŸ¥ç½‘ç»œæˆ–æœåŠ¡å™¨è®¾ç½®');
			}
		}

		// é”®ç›˜å¤„ç†
		function onKeyPress(e) {
			if (e?.keyCode === 13) send();
		}

		function onKeyDown(e) {
			// Tabè‡ªåŠ¨è¡¥å…¨
			if (e.keyCode === 9) {
				e.preventDefault();
				handleAutocomplete();
				return false;
			}
			// å‘½ä»¤å†å²
			if (e.keyCode === 38 || e.keyCode === 40) {
				e.preventDefault();
				if (commandHistory.length > 0) {
					commandIndex = e.keyCode === 38
						? Math.min(commandIndex + 1, commandHistory.length - 1)
						: Math.max(commandIndex - 1, -1);
					input.value = commandIndex === -1 ? '' : commandHistory[commandIndex];
				}
			}
		}

		function onInputChanged(e) {
			// æ¸…ç†è‡ªåŠ¨è¡¥å…¨
			const suggestions = document.getElementById('autocompleteSuggestions');
			if (suggestions) {
				suggestions.classList.remove('visible');
				suggestions.innerHTML = '';
			}
		}

		function handleAutocomplete() {
			const text = input.value;
			const cursorPos = input.selectionStart;
			const textBeforeCursor = text.substring(0, cursorPos);
			const words = textBeforeCursor.split(' ');
			const lastWord = words[words.length - 1];

			if (!lastWord) return;

			let suggestions = [];

			// æ˜µç§°è¡¥å…¨
			if (lastWord.startsWith('@') || !text.startsWith('/')) {
				const searchPrefix = lastWord.startsWith('@') ? lastWord.substring(1) : lastWord;
				if (activeChannel?.users) {
					suggestions = activeChannel.users
						.map(user => user[1])
						.filter(nick => nick.toLowerCase().startsWith(searchPrefix.toLowerCase()))
						.map(nick => lastWord.startsWith('@') ? `@${nick}` : nick);
				}
			}

			// å‘½ä»¤è¡¥å…¨
			if (text.startsWith('/')) {
				const commands = ['/me', '/query', '/ignore', '/whois', '/away', '/list', '/clear'];
				suggestions = commands.filter(cmd => cmd.startsWith(lastWord));
			}

			if (suggestions.length > 0) {
				const suggestion = suggestions[0];
				const replacement = suggestion + (text.startsWith('/') ? '' : ' ');
				words[words.length - 1] = replacement;
				input.value = words.join(' ') + text.substring(cursorPos);
				input.selectionStart = input.selectionEnd = words.join(' ').length + 1;
			}
		}

		// æ ‡ç­¾é¡µç®¡ç†
		function Tab_onClick(evt) {
			if (!evt?.currentTarget) return;
			const chanName = evt.currentTarget.value;
			Tab_Show(chanName);
			evt.currentTarget.classList.remove('unread');
			const countEl = evt.currentTarget.querySelector('.unread-count');
			if (countEl) countEl.remove();
		}

		function Tabs_Hide() {
			document.querySelectorAll('.channelcontent').forEach(el => el.style.display = 'none');
			document.querySelectorAll('.channel').forEach(el => el.classList.remove('active'));
		}

		function Tab_Show(name) {
			if (!name) return;
			const channel = channelMap.get(name);
			if (!channel) return;

			Tabs_Hide();
			if (channel.channel) {
				channel.channel.style.display = 'flex';
				channel.button.classList.add('active');
				activeChannel = channel;
				channel.unreadCount = 0;
			}
		}

		function HTML_escape(text) {
			if (!text) return "";
			const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
			return text.replace(/[&<>"']/g, m => map[m]);
		}

		function sortUserList(a, b) {
			if (!a?.[0] || !b?.[0]) return 0;
			if (a[0][0] === b[0][0])
				return a[1].localeCompare(b[1], undefined, { sensitivity: 'accent' });
			if (!PrefixChars?.[1]) return 0;
			return PrefixChars[1].indexOf(a[0][0]) - PrefixChars[1].indexOf(b[0][0]);
		}

		function Tab_Create(name, topic, createlist) {
			if (!name || !channels || !channelContents) {
				console.error("Tab_Create: ç¼ºå°‘å¿…è¦å…ƒç´ ");
				return;
			}

			Tabs_Hide();
			this.name = name;
			this.unreadCount = 0;

			const escapedName = HTML_escape(name);
			this.button = document.createElement("button");
			this.button.innerHTML = escapedName;
			this.button.value = escapedName;
			this.button.onclick = Tab_onClick;
			this.button.className = "channel active";

			const x = document.createElement("button");
			x.innerHTML = "Ã—";
			x.onclick = Tab_Close;
			x.value = escapedName;
			x.className = "x";
			this.button.appendChild(x);
			channels.appendChild(this.button);

			this.channel = document.createElement("nav");
			this.channel.className = "channelcontent";

			const navContainer = document.createElement("nav");
			this.topic = document.createElement("h3");
			this.topic.innerHTML = HTML_escape(topic || "no channeltopic available");
			navContainer.appendChild(this.topic);

			this.content = document.createElement("nav");
			navContainer.appendChild(this.content);
			this.channel.appendChild(navContainer);

			if (createlist) {
				this.userlist = document.createElement("ul");
				this.users = [];
				this.names_end = true;
				this.channel.appendChild(this.userlist);

				// æ·»åŠ æŠ˜å æŒ‰é’®
				const toggleBtn = document.createElement('button');
				toggleBtn.className = 'toggle-users-btn';
				toggleBtn.textContent = 'ğŸ‘¥';
				toggleBtn.title = 'æŠ˜å /å±•å¼€ç”¨æˆ·åˆ—è¡¨';
				toggleBtn.onclick = function () {
					this.userlist.classList.toggle('collapsed');
					toggleBtn.textContent = this.userlist.classList.contains('collapsed') ? 'ğŸ‘¥' : 'âœ•';
				}.bind(this);
				navContainer.style.position = 'relative';
				navContainer.appendChild(toggleBtn);
			}

			channelContents.appendChild(this.channel);
			channelMap.set(name, this);
			activeChannel = this;
		}

		function Tab_Close(evt) {
			if (!evt?.currentTarget) return;
			const chanName = evt.currentTarget.value;
			doSend("part " + chanName);
			evt.stopPropagation();
		}

		function Channel_Destroy(name) {
			if (!name) return;
			const channel = channelMap.get(name);
			if (!channel) return;

			channel.button.remove();
			channel.channel.remove();
			if (activeChannel === channel) activeChannel = statusChannel;
			channelMap.delete(name);

			if (activeChannel) Tab_Show(activeChannel.name);
		}

		// ç”¨æˆ·ç®¡ç†
		function Channel_InsertUser(nick, channel, prefix) {
			if (!nick || !channel?.userlist) return;

			const user = document.createElement("li");
			const prefixEl = document.createElement("p");
			if (prefix && prefix !== " ") prefixEl.innerHTML = prefix[0];
			user.appendChild(prefixEl);

			const nickEl = document.createElement("p");
			nickEl.innerHTML = HTML_escape(nick);
			user.appendChild(nickEl);

			user.addEventListener('contextmenu', e => {
				e.preventDefault();
				showUserContextMenu(e, nick);
			});

			let i = 0;
			for (; i < channel.users.length; i++) {
				if (channel.users[i]?.[1]?.localeCompare(nick, undefined, { sensitivity: 'accent' }) >= 0) break;
			}
			channel.users.splice(i, 0, [prefix || " ", nick]);
			channel.userlist.insertBefore(user, channel.userlist.childNodes[i]);
		}

		function Channel_AppendUser(nick, channel, dontnotify, prefix) {
			if (!nick || !channel?.userlist) return;

			const user = document.createElement("li");
			const prefixEl = document.createElement("p");
			if (prefix && prefix !== " ") prefixEl.innerHTML = prefix[0];
			user.appendChild(prefixEl);

			const nickEl = document.createElement("p");
			nickEl.innerHTML = HTML_escape(nick);
			user.appendChild(nickEl);

			user.addEventListener('contextmenu', e => {
				e.preventDefault();
				showUserContextMenu(e, nick);
			});

			channel.userlist.appendChild(user);
		}

		function Channel_RemoveUser(nick, channel) {
			if (!nick || !channel?.userlist) return false;

			for (let i = 0; i < channel.userlist.children.length; i++) {
				const userItem = channel.userlist.children[i];
				if (userItem?.children[1]?.textContent === nick) {
					userItem.remove();
					if (channel.users?.[i]) channel.users.splice(i, 1);
					return true;
				}
			}
			return false;
		}

		function Channel_RenameUser(nick, newnick, channel) {
			if (!nick || !newnick || !channel) return false;
			if (!channel.userlist) return false;

			for (let i = 0; i < channel.users.length; i++) {
				if (channel.users[i]?.[1] === nick) {
					const prefix = channel.users[i][0];
					Channel_RemoveUser(nick, channel);
					Channel_InsertUser(newnick, channel, prefix);
					return true;
				}
			}
			return false;
		}

		function Channel_UpdateUserPrefix(nick, channel, add, prefix) {
			if (!nick || !channel?.users || !PrefixChars) return;

			for (let i = 0; i < channel.users.length; i++) {
				if (channel.users[i]?.[1] === nick) {
					const pos = PrefixChars[0].indexOf(prefix);
					if (pos < 0) return;

					let prefixes = "";
					if (add === "true" || add === true) {
						let ii = 0;
						for (; ii < channel.users[i][0].length; ii++) {
							if (PrefixChars[1].indexOf(channel.users[i][0][ii]) >= pos) break;
							prefixes += channel.users[i][0][ii];
						}
						prefixes += PrefixChars[1][pos];
						for (; ii < channel.users[i][0].length; ii++) {
							prefixes += channel.users[i][0][ii];
						}
					} else {
						const tmp = channel.users[i][0].indexOf(PrefixChars[1][pos]);
						if (tmp >= 0) {
							prefixes = channel.users[i][0].substring(0, tmp) + channel.users[i][0].substring(tmp + 1);
						}
					}

					if (prefixes === "") prefixes = " ";
					channel.users[i][0] = prefixes;
					Channel_RenameUser(nick, nick, channel);
					break;
				}
			}
		}

		// æ¶ˆæ¯æ˜¾ç¤º
		function writeToScreen(color, message, channel, username) {
			if (!channel?.content) return;

			const pre = document.createElement("p");
			pre.style.color = color;

			const now = new Date();
			const timeStr = now.toLocaleTimeString('zh-CN', { hour12: false });
			let displayMessage = username ? `[${timeStr}] ${username} â†’ ${linkify(message)}` : `[${timeStr}] ${linkify(message)}`;

			// æåŠé«˜äº®
			if (nickname && message.includes(`@${nickname}`)) {
				displayMessage = displayMessage.replace(
					new RegExp(`@${nickname}`, 'g'),
					`<span class="mention-highlight">@${nickname}</span>`
				);
				// æ¡Œé¢é€šçŸ¥
				if (document.getElementById('enableNotifications')?.checked &&
					Notification.permission === 'granted') {
					new Notification(`${username} @ä½ `, {
						body: message,
						tag: channel.name,
						renotify: true
					});
				}
			}

			pre.innerHTML = displayMessage;
			channel.content.appendChild(pre);

			// é™åˆ¶æ¶ˆæ¯æ•°é‡
			while (channel.content.children.length > 300) {
				channel.content.removeChild(channel.content.firstChild);
			}

			channel.content.scrollTop = channel.content.scrollHeight;

			// æœªè¯»è®¡æ•°
			if (activeChannel !== channel) {
				channel.unreadCount = (channel.unreadCount || 0) + 1;
				updateUnreadCount(channel);
			}
		}

		function updateUnreadCount(channel) {
			const button = channel.button;
			button.classList.add('unread');
			let countEl = button.querySelector('.unread-count');
			if (!countEl) {
				countEl = document.createElement('span');
				countEl.className = 'unread-count';
				button.appendChild(countEl);
			}
			countEl.textContent = channel.unreadCount > 99 ? '99+' : channel.unreadCount;
		}

		function linkify(text) {
			const urlRegex = /(https?:\/\/[^\s<>{}|\\^~[\]`]+)/g;
			return text.replace(urlRegex, function (url) {
				return `<a href="${url}" target="_blank" rel="noopener noreferrer" 
					onmouseover="showLinkPreview(event, '${url}')"
					onmouseout="hideLinkPreview()"
					style="color: var(--clr-accent); text-decoration: underline; word-break: break-all;">${url}</a>`;
			});
		}

		function showLinkPreview(event, url) {
			const preview = document.getElementById('linkPreview');
			if (!preview) return;
			preview.textContent = `ğŸ”— ${url}`;
			preview.classList.add('visible');
			preview.style.left = Math.min(event.pageX + 10, window.innerWidth - 310) + 'px';
			preview.style.top = event.pageY + 10 + 'px';
		}

		function hideLinkPreview() {
			document.getElementById('linkPreview')?.classList.remove('visible');
		}

		function showUserContextMenu(event, nick) {
			const menu = document.getElementById('userContextMenu');
			if (!menu) return;

			menu.innerHTML = `
				<div class="context-menu-item" onclick="doSend('query ${nick}')">ğŸ’¬ ç§èŠ ${nick}</div>
				<div class="context-menu-item" onclick="doSend('whois ${nick}')">ğŸ‘¤ æŸ¥çœ‹ä¿¡æ¯</div>
				<div class="context-menu-item" onclick="ignoreUser('${nick}')">ğŸš« å¿½ç•¥ ${nick}</div>
			`;
			menu.classList.add('visible');
			menu.style.left = Math.min(event.pageX, window.innerWidth - 160) + 'px';
			menu.style.top = Math.min(event.pageY, window.innerHeight - 120) + 'px';
		}

		function ignoreUser(nick) {
			ignoredUsers.add(nick.toLowerCase());
			writeToScreen("var(--clr-gold)", `å·²å¿½ç•¥ç”¨æˆ·: ${nick}`, statusChannel, "");
			writeToLog(`[IGNORE] å·²å¿½ç•¥: ${nick}`);
			document.getElementById('userContextMenu')?.classList.remove('visible');
		}

		// æœç´¢åŠŸèƒ½
		function onSearchKeyUp(event) {
			const searchInput = document.getElementById('searchInput');
			const searchResults = document.getElementById('searchResults');
			if (!searchInput || !searchResults) return;

			const query = searchInput.value.toLowerCase().trim();
			if (query.length === 0) {
				searchResults.classList.remove('visible');
				return;
			}

			if (event.key === 'Enter') {
				const results = [];
				channelMap.forEach((channel, name) => {
					if (!channel.content) return;
					Array.from(channel.content.children).forEach(msg => {
						if (msg.textContent.toLowerCase().includes(query)) {
							results.push({ channel: name, message: msg.textContent, element: msg });
						}
					});
				});

				searchResults.innerHTML = '';
				if (results.length === 0) {
					searchResults.innerHTML = '<div class="search-result-item">æ— åŒ¹é…ç»“æœ</div>';
				} else {
					results.slice(0, 10).forEach(result => {
						const item = document.createElement('div');
						item.className = 'search-result-item';
						item.innerHTML = `<strong>${result.channel}:</strong> ${result.message.substring(0, 60)}${result.message.length > 60 ? '...' : ''}`;
						item.onclick = () => {
							Tab_Show(result.channel);
							result.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
							result.element.style.background = 'var(--clr-highlight)';
							setTimeout(() => result.element.style.background = '', 1500);
							searchResults.classList.remove('visible');
							searchInput.value = '';
						};
						searchResults.appendChild(item);
					});
				}
				searchResults.classList.add('visible');
			}
		}

		// æ¶ˆæ¯å‘é€
		function send() {
			const text = input?.value.trim();
			if (!text || !activeChannel) return;

			// ä¿å­˜å‘½ä»¤å†å²
			if (text.startsWith('/')) {
				commandHistory.unshift(text);
				commandHistory = commandHistory.slice(0, 50);
			}
			commandIndex = -1;

			let msg;
			if (text[0] === "/") {
				const parts = text.split(' ');
				const command = parts[0].toLowerCase();

				switch (command) {
					case '/me':
						msg = `privmsg ${activeChannel.name} :\x01ACTION ${text.substring(4)}\n`;
						writeToScreen("var(--clr-red)", `${nickname} ${text.substring(4)}`, activeChannel, "*");
						break;
					case '/query':
						const target = parts[1];
						if (target && validateNickname(target)) {
							new Tab_Create(target, `Private chat with ${target}`, false);
							writeToLog(`[QUERY] æ‰“å¼€ç§èŠ: ${target}`);
						} else {
							writeToScreen("var(--clr-red)", "æ— æ•ˆçš„æ˜µç§°", statusChannel, "");
						}
						input.value = '';
						return;
					case '/ignore':
						ignoreUser(parts[1]);
						input.value = '';
						return;
					case '/clear':
						if (activeChannel.content) activeChannel.content.innerHTML = '';
						input.value = '';
						return;
					default:
						writeToScreen("var(--clr-font)", text, statusChannel, "");
						msg = text.substring(1) + "\n";
				}
			} else {
				msg = `privmsg ${activeChannel.name} :${text}\n`;
				writeToScreen("var(--clr-font)", text, activeChannel, nickname);
			}

			doSend(msg);
			if (input) input.value = "";
		}

		// WebSocketè¿æ¥
		function WebSocket_Connect(wsUri) {
			if (!wsUri) {
				writeToLog("[ERROR] WebSocketåœ°å€ä¸ºç©º");
				return;
			}

			try {
				if (websocket) {
					try {
						websocket.onclose = null;
						websocket.onerror = null;
						websocket.onopen = null;
						websocket.onmessage = null;
						if (websocket.readyState !== WebSocket.CLOSED) {
							websocket.close(1000, "Reconnecting");
						}
					} catch (e) { }
					websocket = null;
				}

				writeToLog(`[WebSocket] æ­£åœ¨åˆ›å»ºè¿æ¥: ${wsUri}`);
				websocket = new WebSocket(wsUri);
				websocket.binaryType = 'blob';

				const connectTimeout = setTimeout(() => {
					if (websocket && websocket.readyState === WebSocket.CONNECTING) {
						writeToLog(`[ERROR] è¿æ¥è¶…æ—¶ (30ç§’)`);
						try { websocket.close(1006, "Connection timeout"); } catch (e) { }
					}
				}, 30000);

				websocket.onclose = evt => {
					clearTimeout(connectTimeout);
					onClose(evt);
				};
				websocket.onerror = evt => onError(evt);
				websocket.onopen = evt => {
					clearTimeout(connectTimeout);
					onOpen(evt);
				};
				websocket.onmessage = evt => onMessage(evt);
			} catch (e) {
				writeToLog(`[ERROR] WebSocketåˆ›å»ºå¤±è´¥: ${e.message}`);
				onDisconnect();
				if (wsUrl?.startsWith('wss://')) {
					showSSLWarning(wsUrl);
				}
				alert(`è¿æ¥å¤±è´¥: ${e.message}\n\nå¦‚æœæ˜¯SSLè¯ä¹¦é”™è¯¯, è¯·ç‚¹å‡»"SSLå¸®åŠ©"æŸ¥çœ‹è§£å†³æ–¹æ¡ˆ`);
			}
		}

		function onClose(evt) {
			isConnected = false;
			let reason = evt.reason || 'è¿æ¥å…³é—­';
			let code = evt.code;
			let logMsg = `[CLOSE] Code: ${code}`;

			const codeMap = {
				1000: ' (æ­£å¸¸å…³é—­)',
				1006: ' (å¼‚å¸¸æ–­å¼€ - å¯èƒ½SSLè¯ä¹¦é”™è¯¯)',
				1005: ' (æ— çŠ¶æ€ç )',
				1011: ' (æœåŠ¡å™¨å¼‚å¸¸)'
			};
			logMsg += codeMap[code] || (code >= 4000 && code <= 4999 ? ' (åº”ç”¨å±‚é”™è¯¯)' : '');
			logMsg += ` - ${reason}`;

			writeToScreen("var(--clr-font)", "DISCONNECTED", statusChannel, "");
			writeToLog(logMsg);

			if (websocket) {
				try {
					websocket.onclose = null;
					websocket.onerror = null;
					websocket.onopen = null;
					websocket.onmessage = null;
				} catch (e) { }
				websocket = null;
			}
			onDisconnect();
		}

		function onError(evt) {
			let errorType = 'WebSocketé”™è¯¯';
			if (evt?.target) {
				errorType = evt.target.readyState === WebSocket.CONNECTING ? 'è¿æ¥å¤±è´¥' : 'æ¶ˆæ¯é”™è¯¯';
			}

			writeToScreen("var(--clr-red)", `ERROR: ${errorType}`, statusChannel, "");
			writeToLog(`[ERROR] ${errorType}: ${evt.data || 'æœªçŸ¥é”™è¯¯'}`);

			if (wsUrl?.startsWith('wss://')) {
				showSSLWarning(wsUrl);
			}
		}

		function onOpen(evt) {
			isConnected = true;
			reconnectAttempts = 0;

			writeToScreen("var(--clr-font)", "CONNECTED", statusChannel, "");
			writeToLog(`[OPEN] WebSocketè¿æ¥æˆåŠŸ: ${wsUrl}`);
			updateConnectionStatus(true);

			document.querySelector('.channels').style.display = 'flex';
			document.querySelector('.channelcontents').style.display = 'flex';
			document.querySelector('.input-container').style.display = 'block';

			const connectBtn = document.getElementById('connectBtn');
			if (connectBtn) {
				connectBtn.textContent = 'æ–­å¼€';
				connectBtn.disabled = false;
				connectBtn.classList.add('disconnect');
			}

			doSend("user websocket * * :WebSocket User");
			doSend("nick " + nickname);
		}

		function onMessage(evt) {
			if (!evt) return;

			rawData = evt.data;
			writeToLog(`â† RECV: ${typeof rawData === 'string' ? rawData : '[äºŒè¿›åˆ¶æ•°æ®]'}`);

			if (rawData instanceof Blob) {
				const fileReader = new FileReader();
				fileReader.addEventListener("loadend", e => {
					const raw = e.target.result;
					writeToLog(`â† RECV (Blobâ†’Text): ${raw}`);
					process(raw);
				});
				fileReader.readAsText(rawData);
			} else {
				process(rawData);
			}
		}

		function doSend(message) {
			if (!message) return;

			if (websocket?.readyState === WebSocket.OPEN) {
				try {
					websocket.send(message);
					writeToLog(`â†’ SEND: ${message.trim()}`);
				} catch (e) {
					writeToLog(`[ERROR] å‘é€æ¶ˆæ¯å¤±è´¥: ${e.message}`);
					writeToScreen("var(--clr-red)", "å‘é€å¤±è´¥: " + e.message, statusChannel, "");
				}
			} else {
				writeToLog(`[ERROR] WebSocketæœªè¿æ¥, æ— æ³•å‘é€: ${message.trim()}`);
				if (!isConnected) {
					writeToScreen("var(--clr-red)", "æœªè¿æ¥, æ¶ˆæ¯æœªå‘é€", statusChannel, "");
				}
			}
		}

		// IRCå‘½ä»¤å¤„ç†
		const Commands = new Map([
			["001", function (nick, data) {
				doSend("CAP REQ :multi-prefix");
				if (channelName) {
					doSend("join " + channelName);
					writeToLog(`[IRC] æ¥æ”¶001, å‡†å¤‡åŠ å…¥é¢‘é“: ${channelName}`);
				} else {
					writeToLog(`[IRC] æ¥æ”¶001, æœªè®¾ç½®è‡ªåŠ¨åŠ å…¥é¢‘é“`);
				}
			}],
			["005", function (nick, data) {
				if (!data || !PrefixChars) return;
				for (let i = 2; i < data.length; i++) {
					if (data[i].indexOf("PREFIX=") === 0) {
						const tmp = data[i].substring(8) + " ";
						if (tmp) {
							PrefixChars = tmp.split(")");
							writeToScreen("var(--clr-brown)", "PREFIX CHARS: " + PrefixChars[0] + " " + PrefixChars[1], statusChannel, "");
							writeToLog(`[IRC] æ”¯æŒçš„PREFIX: ${PrefixChars[0]} ${PrefixChars[1]}`);
						}
					}
				}
			}],
			["332", function (nick, data) {
				if (!data || data.length < 5) return;
				const channel = channelMap.get(data[3]);
				if (!channel?.topic) return;

				let text = data[4].substring(1);
				for (let i = 5; i < data.length; i++) text += " " + data[i];

				channel.topic.innerHTML = HTML_escape(text || "no channeltopic available");
				writeToLog(`[IRC] é¢‘é“ä¸»é¢˜: ${data[3]} - ${text}`);
			}],
			["353", function (nick, data) {
				if (!data || data.length < 6) return;
				const channel = channelMap.get(data[4]);
				if (!channel) return;

				if (channel.names_end === true) {
					channel.users = [];
					channel.names_end = false;
				}

				data[5] = data[5].substring(1);
				for (let i = 5; i < data.length; i++) {
					let prefix = "", ii = 0;
					while (PrefixChars?.[1] && PrefixChars[1].indexOf(data[i][ii]) >= 0) {
						prefix += data[i][ii];
						ii++;
					}
					if (prefix === "") prefix = " ";
					channel.users.push([prefix, data[i].substring(ii)]);
				}
				writeToLog(`[IRC] æ¥æ”¶ç”¨æˆ·åˆ—è¡¨: ${channel.users.length} ç”¨æˆ·`);
			}],
			["366", function (nick, data) {
				if (!data || data.length < 4) return;
				const channel = channelMap.get(data[3]);
				if (!channel) return;

				channel.users.sort(sortUserList);
				channel.userlist.innerHTML = "";
				channel.users.forEach(user => Channel_AppendUser(user[1], channel, true, user[0]));
				channel.names_end = true;
				writeToLog(`[IRC] ç”¨æˆ·åˆ—è¡¨åŠ è½½å®Œæˆ`);
			}],
			["432", function (nick, data) {
				nickname = prompt("ERROR: Nickname is unavailable: Illegal characters\r\nPlease enter your nickname", "");
				doSend("nick " + nickname);
				writeToLog(`[IRC] æ˜µç§°é”™è¯¯, é‡æ–°è¾“å…¥: ${nickname}`);
			}],
			["433", function (nick, data) {
				nickname = prompt("ERROR: Nickname is already in use.\r\nPlease enter your nickname", "");
				doSend("nick " + nickname);
				writeToLog(`[IRC] æ˜µç§°å†²çª, æ–°æ˜µç§°: ${nickname}`);
			}],
			["JOIN", function (nick, data) {
				if (!data || data.length < 3) return;
				if (ignoredUsers.has(nick.toLowerCase())) return;

				if (data[0].indexOf(":" + nickname + "!") !== 0) {
					if (data[2][0] === ":") data[2] = data[2].substring(1);
					const channel = channelMap.get(data[2]);
					if (!channel) return;
					Channel_InsertUser(nick, channel, " ");
				} else {
					const channel = new Tab_Create(data[2].substring(1), "", true);
					nick = nickname;
				}
				writeToScreen("var(--clr-green)", `${nick} åŠ å…¥é¢‘é“`, channel, "*");
				writeToLog(`[IRC] ç”¨æˆ·åŠ å…¥: ${nick} -> ${data[2]}`);
			}],
			["KICK", function (nick, data) {
				if (!data || data.length < 5) return;
				const channel = channelMap.get(data[2]);
				if (!channel) return;

				let text = data[4].substring(1);
				for (let i = 5; i < data.length; i++) text += " " + data[i];

				if (data[3] !== nickname) {
					if (Channel_RemoveUser(data[3], channel)) {
						writeToScreen("var(--clr-green)", `${data[3]} è¢« ${nick} è¸¢å‡º (åŸå› : ${text})`, channel, "*");
					}
					return;
				}
				Channel_Destroy(data[2]);
				writeToScreen("var(--clr-font)", `ä½ è¢« ${nick} è¸¢å‡º ${data[2]} (åŸå› : ${text})`, statusChannel, "");
				writeToLog(`[IRC] è¢«è¸¢å‡º: ${data[2]} by ${nick} - ${text}`);
			}],
			["MODE", function (nick, data) {
				if (!data || data.length < 4) return;
				const channel = channelMap.get(data[2]);
				if (!channel) return;

				let text = data[3];
				for (let i = 4; i < data.length; i++) text += " " + data[i];

				writeToScreen("var(--clr-green)", `${nick} è®¾ç½®æ¨¡å¼: ${text}`, channel, "*");
				if (!PrefixChars || data[3].length < 1) return;

				let ii = 4, status = "false";
				for (let i = 0; i < data[3].length; i++) {
					if (data[3][i] === "+") status = "true";
					else if (data[3][i] === "-") status = "false";
					else if (ii < data.length) {
						Channel_UpdateUserPrefix(data[ii], channel, status, data[3][i]);
						ii++;
					}
				}
				writeToLog(`[IRC] æ¨¡å¼å˜æ›´: ${text}`);
			}],
			["NICK", function (nick, data) {
				if (!data || data.length < 3) return;
				const newnick = data[2].substring(1);
				if (nick === nickname) nickname = newnick;

				channelMap.forEach((channel, name) => {
					if (Channel_RenameUser(nick, newnick, channel)) {
						const message = newnick === nickname ? `ä½ ç°åœ¨çš„æ–°æ˜µç§°æ˜¯ ${newnick}` : `${nick} æ›´åä¸º ${newnick}`;
						writeToScreen("var(--clr-green)", message, channel, "*");
					}
				});
				writeToLog(`[IRC] æ˜µç§°å˜æ›´: ${nick} -> ${newnick}`);
			}],
			["PART", function (nick, data) {
				if (!data || data.length < 3) return;
				if (ignoredUsers.has(nick.toLowerCase())) return;

				if (data[0].indexOf(":" + nickname + "!") !== 0) {
					const channel = channelMap.get(data[2]);
					if (!channel) return;
					if (Channel_RemoveUser(nick, channel)) {
						writeToScreen("var(--clr-green)", `${nick} ç¦»å¼€é¢‘é“`, channel, "*");
					}
					return;
				}
				Channel_Destroy(data[2]);
				writeToLog(`[IRC] ç¦»å¼€é¢‘é“: ${data[2]}`);
			}],
			["TOPIC", function (nick, data) {
				if (!data || data.length < 4) return;
				const channel = channelMap.get(data[2]);
				if (!channel?.topic) return;

				let text = data[3].substring(1);
				for (let i = 4; i < data.length; i++) text += " " + data[i];

				channel.topic.innerHTML = HTML_escape(text || "no channeltopic available");
				writeToScreen("var(--clr-green)", `${nick} è®¾ç½®ä¸»é¢˜ä¸º: ${text}`, channel, "*");
				writeToLog(`[IRC] ä¸»é¢˜å˜æ›´: ${data[2]} - ${text}`);
			}],
			["QUIT", function (nick, data) {
				if (ignoredUsers.has(nick.toLowerCase())) return;

				channelMap.forEach((channel, name) => {
					if (Channel_RemoveUser(nick, channel)) {
						writeToScreen("var(--clr-blue)", `${nick} é€€å‡ºIRC`, channel, "*");
					}
				});
				writeToLog(`[IRC] ç”¨æˆ·é€€å‡º: ${nick}`);
			}],
			["PRIVMSG", function (nick, data) {
				if (!data || data.length < 4) return;
				if (ignoredUsers.has(nick.toLowerCase())) {
					writeToLog(`[IGNORED] å¿½ç•¥ ${nick} çš„æ¶ˆæ¯`);
					return;
				}

				let channel = channelMap.get(data[2]);
				let isPrivate = false;

				if (!channel && data[2] === nickname) {
					channel = channelMap.get(nick);
					if (!channel) channel = new Tab_Create(nick, `Private chat with ${nick}`, false);
					isPrivate = true;
				} else if (!channel) {
					channel = statusChannel;
				}

				let text = data[3].substring(1);
				for (let i = 4; i < data.length; i++) text += " " + data[i];

				nick = data[0].substring(1).split("!")[0];
				if (text[0] === "\x01") {
					if (text.indexOf("\x01ACTION ") === 0) {
						writeToScreen("var(--clr-red)", `${isPrivate ? '' : '* '}${nick} ${text.substring(8)}`, channel, isPrivate ? nick : "*");
					} else {
						writeToScreen("var(--clr-red)", `${nick} ${text}`, channel, "*");
					}
				} else {
					writeToScreen("var(--clr-font)", text, channel, nick);
				}
			}],
			["NOTICE", function (nick, data) {
				if (!data || data.length < 4) return;
				const channel = channelMap.get(data[2]) || statusChannel;

				let text = data[3].substring(1);
				for (let i = 4; i < data.length; i++) text += " " + data[i];

				nick = data[0].substring(1).split("!")[0];
				writeToScreen("var(--clr-red)", `é€šçŸ¥ ${nick}: ${text}`, channel, "-");
				writeToLog(`[NOTICE] ${nick}: ${text}`);
			}]
		]);

		function process(rawData) {
			if (!rawData) return;

			const data = rawData.split(" ");
			if (!data || data.length < 2) {
				writeToLog(`[DEBUG] æ— æ•ˆæ•°æ®: ${rawData}`);
				return;
			}

			const nick = data[0].substring(1).split("!")[0];
			const command = data[1].toUpperCase();
			const fn = Commands.get(command);

			if (fn) {
				fn(nick, data);
				return;
			}

			if (!isNaN(parseInt(data[1]))) {
				let text = data[1];
				for (let i = 3; i < data.length; i++) text += " " + data[i];
				writeToScreen("var(--clr-gold)", text, statusChannel, "");
				writeToLog(`[SERVER] ${data[1]}: ${text}`);
				return;
			}

			if (data[0] === "PING") {
				const pongResponse = rawData.replace("PING", "PONG");
				writeToScreen("var(--clr-brown)", pongResponse, statusChannel, "");
				doSend(pongResponse);
				writeToLog(`[PING/PONG] ${pongResponse}`);
				return;
			}

			if (data[0] === "ERROR") {
				writeToScreen("var(--clr-font)", rawData, statusChannel, "");
				writeToLog(`[ERROR] ${rawData}`);
				return;
			}

			writeToLog(`[DEBUG] ${rawData}`);
		}
	</script>
</body>

</html>