/*
 * OperServ 示例配置文件
 */

service 
{
	/*
	 * OperServ 客户端的名称
	 * 如果您更改此值 您可能还想更改 operserv 模块配置中的客户端指令
	 */
	nick = "OperServ"
 
	/*
	 * OperServ 客户端的用户名
	 */
	user = "services"
 
	/*
	 * OperServ 客户端的主机名
	 */
	host = "services.host" 
 
	/*
	 * OperServ 客户端的真实姓名
	 */
	gecos = "Operator Service"
 
	/*
	 * 此客户端应使用的模式
	 * 除非您知道自己在做什么 否则不要修改此设置
	 *
	 * 这些模式非常特定于 IRCd如果保留注释 将根据您加载的协议模块使用合理的默认值
	 *
	 * 请注意 错误设置此选项可能会破坏客户端的部分甚至全部功能如果启用此选项后客户端无法执行某些操作 我们将不提供支持
	 */
	#modes = "+o"
 
	/*
	 * 此服务应加入的频道的可选逗号分隔列表除了日志频道外 这不太有用 因为服务将只在指定的频道中空闲 
	 * 并且不会接受任何类型的命令
	 *
	 * 频道可以使用模式字符或前缀符号的形式给出前缀
	 */
	#channels = "@#services,#mychan"
}
 
/*
 * 核心 OperServ 模块
 *
 * 为 OperServ 提供基本功能
 */
module 
{
	name = "operserv"
 
	/*
	 * 应该是 OperServ 的客户端名称
	 */
	client = "OperServ"
 
	/*
	 * 这些分别定义了 AKILLs、CHANKILLs、SNLINEs 和 SQLINEs 的默认过期时间
	 */
	autokillexpiry = 30d 
	chankillexpiry = 30d 
	snlineexpiry = 30d 
	sqlineexpiry = 30d 
 
	/*
	 * 如果设置此选项 服务将在添加 AKILL 后立即发送 AKILL 命令这消除了在添加 AKILL 后杀死用户的需要
	 *
	 * 此指令是可选的 但推荐使用
	 */
	akillonadd = yes 
 
	/*
	 * 如果设置此选项 服务将在添加 SNLINE 后立即发送 (SVS)KILL 命令这消除了在添加 SNLINE 后杀死用户的需要
	 *
	 * 此指令是可选的
	 */
	killonsnline = yes 
 
	/*
	 * 如果设置此选项 服务将在添加 SQLINE 后立即发送 (SVS)KILL 命令这消除了在添加 SQLINE 后杀死用户的需要
	 *
	 * 此指令是可选的
	 */
	killonsqline = yes 
 
	/*
	 * 将发出 AKILL 的 IRC 操作员的昵称添加到杀死原因中
	 *
	 * 此指令是可选的
	 */
	addakiller = yes 
 
	/*
	 * 向 akills 添加 akill IDsAkill IDs 被给予用户的封禁原因中 并且可以用来轻松查看、修改或从 ID 中删除一个 akill
	 */
	akillids = yes 
 
	/*
	 * 如果设置 只有 IRC 操作员将被允许使用 OperServ 无论命令访问限制如何
	 *
	 * 此指令是可选的 但推荐使用
	 */
	opersonly = yes 
}

/*
 * 核心 OperServ 命令
 *
 * 在 Anope 中 模块可以提供(多个)命令 每个命令都有一个唯一的命令名称一旦加载了这些模块 
 * 您就可以配置命令 将其添加到您喜欢的任何客户端 并使用任何您喜欢的名称
 *
 * 此外 您可以提供一个权限名称 该名称必须是执行命令的用户 opertype 中的
 *
 * 下面提供了合理的默认设置 除非您希望更改默认行为 否则无需编辑
 */
 
/* 给它一个帮助命令 */
command { service = "OperServ"; name = "HELP"; command = "generic/help"; }
 
/*
 * os_akill 
 *
 * 提供 operserv/akill 命令
 *
 * 用于将用户从网络中封禁
 */
module { name = "os_akill" }
command { service = "OperServ"; name = "AKILL"; command = "operserv/akill"; permission = "operserv/akill"; }
 
/*
 * os_chankill 
 *
 * 提供 operserv/chankill 命令
 *
 * 用于从整个频道中 akill 用户
 */
module { name = "os_chankill" }
command { service = "OperServ"; name = "CHANKILL"; command = "operserv/chankill"; permission = "operserv/chankill"; }
 
/*
 * os_defcon 
 *
 * 提供 operserv/defcon 命令
 *
 * 允许您将服务设置为 DefCon 模式 这可用于在机器人攻击期间限制服务访问
 */
#module 
{
	name = "os_defcon"
 
	/*
	 * 启动服务时使用的默认 DefCon 级别(1-5)级别 5 表示正常操作 而级别 1 表示最严格的操作如果省略此设置或设置为 
	 * 0 DefCon 将被禁用 本块中的其余设置将被忽略
	 */
	#defaultlevel = 5 
 
	/*
	 * 以下 4 个指令定义了当 DefCon 设置为 1 至 4 级时将执行的操作每个级别都是一个必须用空格分隔的列表
	 *
	 * 可以在每个级别定义以下操作: 
	 * - nonewchannels: 禁用注册新频道 
	 * - nonewnicks: 禁用注册新昵称 
	 * - nomlockchanges: 禁用更改注册频道的 MLOCK 
	 * - forcechanmodes: 强制所有频道具有稍后 chanmodes 指令中给出的模式 
	 * - reducedsessions: 将会话限制减少到稍后 sessionlimit 指令中给出的值 
	 * - nonewclients: KILL 任何尝试连接的新客户端 
	 * - operonly: 服务将忽略所有非 IRCops 
	 * - silentoperonly: 服务将静默忽略所有非 IRCops 
	 * - akillnewclients: AKILL 任何尝试连接的新客户端 
	 * - nonewmemos: 不发送新备忘录以阻止 MemoServ 攻击 
	 */
	level4 = "nonewchannels nonewnicks nomlockchanges reducedsessions"
	level3 = "nonewchannels nonewnicks nomlockchanges forcechanmodes reducedsessions"
	level2 = "nonewchannels nonewnicks nomlockchanges forcechanmodes reducedsessions silentoperonly"
	level1 = "nonewchannels nonewnicks nomlockchanges forcechanmodes reducedsessions silentoperonly akillnewclients"
 
	/*
	 * 当 DefCon 级别使用“减少”的会话限制时使用的新的会话限制
	 */
	#sessionlimit = 2 
 
	/*
	 * 当 DefCon 阻止新客户端连接到网络时 添加 AKILL 的时间长度
	 */
	#akillexpire = 5m 
 
	/*
	 * 当使用 DefCon 频道模式系统时 在所有频道上设置的频道模式
	 *
	 * 注意 1: 仔细选择这些模式 因为当 DefCon 切换到一个没有选择模式设置的级别时 服务将在所有频道上设置相反的模式 例如 如果此设置为 +RN 当使用 DefCon 时 所有频道将被设置为 +RN 当移除 DefCon 时 所有 
	 * 频道将被设置为 -RN您不想将其设置为 +k 例如 因为当移除 DefCon 时 所有频道都设置为 -k 从而从之前加锁的频道中移除密钥
	 *
	 * 注意 2: MLOCKed 模式不会丢失
	 */
	#chanmodes = "+R"
 
	/*
	 * 此值可用于在指定的时间段后自动将网络恢复到 DefCon 级别 5 以防任何 IRC 操作员忘记移除 DefCon 设置
	 *
	 * 此指令是可选的
	 */
	#timeout = 15m 
 
	/*
	 * 如果设置 服务将在 DefCon 级别更改时发送全局消息
	 *
	 * 此指令是可选的
	 */
	#globalondefcon = yes 
 
	/*
	 * 如果设置 服务将在 DefCon 级别更改时发送 message 指令中定义的全局消息
	 *
	 * 此指令是可选的
	 */
	#globalondefconmore = yes 
 
	/*
	 * 定义了当 globalondefconmore 设置时 在 DefCon 级别更改时发送的消息
	 *
	 * 仅当 globalondefconmore 设置时才需要此指令
	 */
	#message = "在此处输入要发送给用户的信息别忘了取消注释 globalondefconmore"
 
	/*
	 * 定义了当 DefCon 恢复到级别 5 时发送的消息此指令是可选的 
	 * 并且设置后也会覆盖 globalondefcon 和 globalondefconmore
	 */
	offmessage = "服务现已恢复正常 给您带来不便请谅解"
 
	/*
	 * 定义了在正常 DefCon 操作有效时 客户端从网络中被 KILL 或 AKILL 的原因
	 */
	akillreason = "此网络目前不接受连接 请稍后再试"
}
#command { service = "OperServ"; name = "DEFCON"; command = "operserv/defcon"; permission = "operserv/defcon"; }

/*
 * os_dns 
 *
 * 提供 operserv/dns 命令
 *
 * 此模块要求加载 m_dns
 *
 * 此模块允许控制 DNS 区域这对于 
 * 控制用户被放置在哪个服务器上进行负载均衡很有用 
 * 并自动移除分裂服务器
 *
 * 要使用此模块 您必须为 services 设置一个 nameserver 记录 
 * 以便 DNS 查询发送到 services
 *
 * 或者 您可以使用从属 DNS 服务器隐藏服务的 IP 
 * 提供查询缓存 并提供更好的容错能力
 *
 * 要使用 BIND 进行此操作 请配置类似以下内容: 
 *
 * options { max-refresh-time 60; };
 * zone "irc.example.com"  IN {
 *   type slave;
 *   masters { 127.0.0.1 port 5353; };
 * };
 *
 * 其中 127.0.0.1:5353 是 services 正在监听的 IP 和端口
 * 我们建议您对外部防火墙 UDP 和 TCP 到 Anope 正在监听的端口 
 *
 * 最后为 irc.example.com.  设置一个 NS 记录给 BIND 或 services
 */
#module 
{
	name = "os_dns"
 
	/* 记录的 TTL如果您的记录经常更改 这应该非常低 */
	ttl = 1m 
 
	/* 如果服务器丢弃这么多用户 服务器将自动从 DNS 区域中移除
	 * 此指令是可选的
	 */
	user_drop_mark = 50 
 
	/* 用于 user_drop_mark 的时间
	 */
	user_drop_time = 1m 
 
	/* 当服务器因丢弃用户而从区域中移除时 在此时间后重新添加
	 * 此指令是可选的
	 */
	user_drop_readd_time = 5m 
 
	/* 如果设置 当服务器分裂时 它将自动从区域中移除
	 */
	remove_split_servers = yes 
 
	/* 如果设置 当服务器连接到网络时 如果它是已知服务器 
	 * 将自动添加到区域中
	 */
	readd_connected_servers = no 
}
#command { service = "OperServ"; name = "DNS"; command = "operserv/dns"; permission = "operserv/dns"; }
 
/*
 * os_config 
 *
 * 提供 operserv/config 命令
 *
 * 用于在 services 运行时查看和设置配置选项
 */
module { name = "os_config" }
command { service = "OperServ"; name = "CONFIG"; command = "operserv/config"; permission = "operserv/config"; }
 
/*
 * os_forbid 
 *
 * 提供 operserv/forbid 命令
 *
 * 用于禁止使用特定的昵称、频道、电子邮件等
 */
module { name = "os_forbid" }
command { service = "OperServ"; name = "FORBID"; command = "operserv/forbid"; permission = "operserv/forbid"; }
 
/*
 * os_ignore 
 *
 * 提供 operserv/ignore 命令
 *
 * 用于使服务忽略用户
 */
module { name = "os_ignore" }
command { service = "OperServ"; name = "IGNORE"; command = "operserv/ignore"; permission = "operserv/ignore"; }
 
/*
 * os_info 
 *
 * 提供 operserv/info 命令
 *
 * 用于向用户和频道添加仅操作员注释
 */
module { name = "os_info" }
command { service = "OperServ"; name = "INFO"; command = "operserv/info"; permission = "operserv/info"; }
 
/*
 * os_jupe 
 *
 * 提供 operserv/jupe 命令
 *
 * 用于将服务器从网络中断开连接并防止它们重新连接
 */
module { name = "os_jupe" }
command { service = "OperServ"; name = "JUPE"; command = "operserv/jupe"; permission = "operserv/jupe"; }
 
/*
 * os_kick 
 *
 * 提供 operserv/kick 命令
 *
 * 用于将用户从频道中踢出
 */
module { name = "os_kick" }
command { service = "OperServ"; name = "KICK"; command = "operserv/kick"; permission = "operserv/kick"; }
 
/*
 * os_kill 
 *
 * 提供 operserv/kill 命令
 *
 * 用于强制将用户从网络中断开连接
 */
module { name = "os_kill" }
command { service = "OperServ"; name = "KILL"; command = "operserv/kill"; permission = "operserv/kill"; }
 
/*
 * os_list 
 *
 * 提供 operserv/chanlist 和 operserv/userlist 命令
 *
 * 用于列出和搜索当前在网络上的频道和用户
 */
module { name = "os_list" }
command { service = "OperServ"; name = "CHANLIST"; command = "operserv/chanlist"; permission = "operserv/chanlist"; }
command { service = "OperServ"; name = "USERLIST"; command = "operserv/userlist"; permission = "operserv/userlist"; }
 
/*
 * os_login 
 *
 * 提供 operserv/login 和 operserv/logout 命令
 *
 * 用于登录到 OperServ 只有当您的 oper 块需要此操作时才需要
 */
module { name = "os_login" }
command { service = "OperServ"; name = "LOGIN"; command = "operserv/login"; }
command { service = "OperServ"; name = "LOGOUT"; command = "operserv/logout"; }
 
/*
 * os_logsearch 
 *
 * 提供 operserv/logsearch 命令
 *
 * 用于搜索 services 日志文件
 */
module 
{
	name = "os_logsearch"
 
	/* 要搜索的日志文件名应该配置一个 log{} 块来记录 
	 * 到此名称的文件
	 */
	logname = "services.log" 
}
command { service = "OperServ"; name = "LOGSEARCH"; command = "operserv/logsearch"; permission = "operserv/logsearch"; }

/*
 * os_mode 
 *
 * 提供 operserv/mode 和 operserv/umode 命令
 *
 * 用于更改用户和频道模式
 */
module { name = "os_mode" }
command { service = "OperServ"; name = "UMODE"; command = "operserv/umode"; permission = "operserv/umode"; }
command { service = "OperServ"; name = "MODE"; command = "operserv/mode"; permission = "operserv/mode"; }
 
/*
 * os_modinfo 
 *
 * 提供 operserv/modinfo 和 operserv/modlist 命令
 *
 * 用于显示已加载模块的信息
 */
module { name = "os_modinfo" }
command { service = "OperServ"; name = "MODINFO"; command = "operserv/modinfo"; permission = "operserv/modinfo"; }
command { service = "OperServ"; name = "MODLIST"; command = "operserv/modlist"; permission = "operserv/modinfo"; }
 
/*
 * os_module 
 *
 * 提供 operserv/modload、operserv/modreload 和 operserv/modunload 命令
 *
 * 用于加载、重新加载和卸载模块
 */
module { name = "os_module" }
command { service = "OperServ"; name = "MODLOAD"; command = "operserv/modload"; permission = "operserv/modload"; }
command { service = "OperServ"; name = "MODRELOAD"; command = "operserv/modreload"; permission = "operserv/modload"; }
command { service = "OperServ"; name = "MODUNLOAD"; command = "operserv/modunload"; permission = "operserv/modload"; }
 
/*
 * os_news 
 *
 * 提供 operserv/logonnews、operserv/opernews 和 operserv/randomnews 命令
 *
 * 用于配置用户在连接时以及操作员操作时显示的新闻通知
 */
module 
{
	name = "os_news"
 
	/*
	 * 用于向连接的用户以及在操作时向操作员发送新闻的服务机器人名称 
	 */
	announcer = "Global"
	oper_announcer = "OperServ"
 
	/*
	 * 用户登录时显示的 LOGON/OPER 新闻条目数量
	 *
	 * 此指令是可选的 如果不设置 默认为 3
	 */
	#newscount = 3 
}
command { service = "OperServ"; name = "LOGONNEWS"; command = "operserv/logonnews"; permission = "operserv/news"; }
command { service = "OperServ"; name = "OPERNEWS"; command = "operserv/opernews"; permission = "operserv/news"; }
command { service = "OperServ"; name = "RANDOMNEWS"; command = "operserv/randomnews"; permission = "operserv/news"; }
 
/*
 * os_noop 
 *
 * 提供 operserv/noop 命令
 *
 * 用于对服务器进行 NOOP 操作 防止用户在该服务器上进行操作
 */
module { name = "os_noop" }
command { service = "OperServ"; name = "NOOP"; command = "operserv/noop"; permission = "operserv/noop"; }
 
/*
 * os_oline 
 *
 * 提供 operserv/oline 命令
 *
 * 用于为用户设置操作员标志 特定于 UnrealIRCd 3.2
 * 有关更多信息 请查看您的 IRCd 上的帮助命令 /helpop ?svso
 */
#module { name = "os_oline" }
#command { service = "OperServ"; name = "OLINE"; command = "operserv/oline"; permission = "operserv/oline"; }
 
/*
 * os_oper 
 *
 * 提供 operserv/oper 命令
 *
 * 用于配置操作员并显示有关操作类型的的信息
 */
module { name = "os_oper" }
command { service = "OperServ"; name = "OPER"; command = "operserv/oper"; permission = "operserv/oper"; }
 
/*
 * os_reload 
 *
 * 提供 operserv/reload 命令
 *
 * 用于重新加载 services.conf  配置文件
 */
module { name = "os_reload" }
command { service = "OperServ"; name = "RELOAD"; command = "operserv/reload"; permission = "operserv/reload"; }
 
/*
 * os_session 
 *
 * 提供 operserv/exception 和 operserv/session 命令
 *
 * 此模块启用会话限制会话限制防止用户从同一 IP 同时连接超过一定次数 - 从而防止大多数类型的克隆
 * 一旦主机达到其会话限制 所有尝试从该主机连接的客户端将被杀死
 * 可以通过例外列表定义默认会话限制的例外情况
 *
 * 用于管理会话限制例外列表 并查看当前活动会话
 */
module 
{
	name = "os_session"
 
	/*
	 * 每个主机的默认会话限制一旦主机达到其会话限制 所有尝试 
	 * 从该主机连接的客户端将被杀死
	 *
	 * 如果加载了 os_session 则需要此指令
	 */
	defaultsessionlimit = 3 
 
	/*
	 * 可以为例外中的主机设置的最大会话限制
	 *
	 * 如果加载了 os_session 则需要此指令
	 */
	maxsessionlimit = 100 
 
	/*
	 * 设置会话例外情况的默认过期时间
	 */
	#exceptionexpiry = 1d 
 
	/*
	 * 在用户因主机会话限制超时而即将被从网络中移除之前 将向用户发送 NOTICE
	 * 它可用于提供比简单的“会话限制超时”更详细的即将进行的杀戮的原因
	 *
	 * 此指令是可选的 如果不设置 将不会发送任何内容
	 */
	sessionlimitexceeded = "您的 IP %IP% 的会话限制已超时"
 
	/*
	 * 与上述相同 但应用于提供一个网站地址 用户可以在该网站上了解更多 
	 * 关于会话限制以及如何申请例外的信息
	 *
	 * 注意: 此指令已被故意注释掉 以提醒您更改其包含的 URL建议您提供一个地址/URL 人们可以从中获取有关会话限制的帮助
	 *
	 * 此指令是可选的 如果不设置 将不会发送任何内容
	 */
	#sessionlimitdetailsloc = "请访问 https://your.website.url/  以获取有关会话限制的更多信息"
 
	/*
	 * 如果设置且不为 0 此指令告诉服务在相同主机的后续杀戮数量超过此值时添加 AKILL 
	 * 防止网络经历 KILL 洪水
	 *
	 * 此指令是可选的
	 */
	maxsessionkill = 15 
 
	/*
	 * 设置超过 maxsessionkill 指令限制的主机设置的 AKILL 的过期时间
	 *
	 * 此指令是可选的 如果不设置 默认为 30 分钟
	 */
	sessionautokillexpiry = 30m 
 
	/*
	 * 设置用于确定哪些 IP 地址代表同一人的 CIDR 值
	 * 默认情况下 这将限制每个 IPv4 IP 为 3 个连接 每个 IPv6 IP 为 3 个连接
	 * 如果您正在遭受 IPv6 克隆攻击 将 session_ipv6_cidr 设置为 
	 * 64 或 48 可能会有用
	 */
	session_ipv4_cidr = 32 
	session_ipv6_cidr = 128 
}
command { service = "OperServ"; name = "EXCEPTION"; command = "operserv/exception"; permission = "operserv/exception"; }
command { service = "OperServ"; name = "SESSION"; command = "operserv/session"; permission = "operserv/session"; }
 
/*
 * os_set 
 *
 * 提供 operserv/set 命令
 *
 * 用于设置各种设置 如超级管理员、调试模式等
 */
module 
{
	name = "os_set"
 
	/*
	 * 如果设置 服务管理员将能够使用 SUPERADMIN [ON|OFF] 这将临时授予 
	 * 他们额外权限 例如成为所有频道的创始人
	 *
	 * 此指令是可选的
	 */
	#superadmin = yes 
}
command { service = "OperServ"; name = "SET"; command = "operserv/set"; permission = "operserv/set"; }
 
/*
 * os_shutdown 
 *
 * 提供 operserv/quit、operserv/restart 和 operserv/shutdown 命令
 *
 * 用于退出、重新启动或关闭服务
 */
module { name = "os_shutdown" }
command { service = "OperServ"; name = "QUIT"; command = "operserv/quit"; permission = "operserv/quit"; }
command { service = "OperServ"; name = "RESTART"; command = "operserv/restart"; permission = "operserv/restart"; }
command { service = "OperServ"; name = "SHUTDOWN"; command = "operserv/shutdown"; permission = "operserv/shutdown"; }
 
/*
 * os_stats 
 *
 * 提供 operserv/stats 命令
 *
 * 用于显示有关服务的信息
 */
module { name = "os_stats" }
command { service = "OperServ"; name = "STATS"; command = "operserv/stats"; permission = "operserv/stats"; }
 
/*
 * os_svs 
 *
 * 提供 operserv/svsnick、operserv/svsjoin 和 operserv/svspart 命令
 *
 * 用于强制用户更改昵称 加入和离开频道
 */
module { name = "os_svs" }
command { service = "OperServ"; name = "SVSNICK"; command = "operserv/svsnick"; permission = "operserv/svs"; }
command { service = "OperServ"; name = "SVSJOIN"; command = "operserv/svsjoin"; permission = "operserv/svs"; }
command { service = "OperServ"; name = "SVSPART"; command = "operserv/svspart"; permission = "operserv/svs"; }
 
/*
 * os_sxline 
 *
 * 提供 operserv/snline 和 operserv/sqline 命令
 *
 * 用于禁止真实姓名、昵称 可能还有频道
 */
module { name = "os_sxline" }
command { service = "OperServ"; name = "SNLINE"; command = "operserv/snline"; permission = "operserv/snline"; }
command { service = "OperServ"; name = "SQLINE"; command = "operserv/sqline"; permission = "operserv/sqline"; }
 
/*
 * os_update 
 *
 * 提供 operserv/update 命令
 *
 * 用于立即更新数据库
 */
module { name = "os_update" }
command { service = "OperServ"; name = "UPDATE"; command = "operserv/update"; permission = "operserv/update"; }