<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"> 
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
/* 原有样式保持不变，添加新样式 */
:root {
	--clr-background: #F5F7FA;
	--clr-background2: #E4E7F4;
	--clr-background3: #FFFFFF;
	--clr-background4: #D1D5DB;
	--clr-font: #1F2937;
	--clr-brown: #92400E;
	--clr-green: #065F46;
	--clr-gold: #D97706;
	--clr-red: #DC2626;
	--clr-purple: #7C3AED;
	--clr-blue: #2563EB;
	--clr-accent: #4F46E5;
	--clr-border: #9CA3AF;
	--clr-warning: #F59E0B;
	--clr-success: #10B981;
}

@media (prefers-color-scheme: dark) {
	:root {
		--clr-background: #111827;
		--clr-background2: #1F2937;
		--clr-background3: #1F2937;
		--clr-background4: #4B5563;
		--clr-font: #F9FAFB;
		--clr-brown: #FDE68A;
		--clr-green: #6EE7B7;
		--clr-gold: #FBBF24;
		--clr-red: #FCA5A5;
		--clr-purple: #C4B5FD;
		--clr-blue: #93C5FD;
		--clr-accent: #818CF8;
		--clr-border: #4B5563;
		--clr-warning: #FCD34D;
		--clr-success: #6EE7B7;
	}
}

/* ... 原有样式保持不变 ... */

/* 新增：连接状态指示器 */
.connection-status {
	display: inline-flex;
	align-items: center;
	gap: 6px;
	padding: 4px 10px;
	background-color: var(--clr-background3);
	border: 1px solid var(--clr-border);
	border-radius: 6px;
	font-size: 11px;
	font-weight: 500;
	margin-left: auto;
	transition: all 0.3s;
}

.connection-status.connected {
	border-color: var(--clr-success);
	background-color: rgba(16, 185, 129, 0.1);
}

.connection-status.disconnected {
	border-color: var(--clr-red);
	background-color: rgba(220, 38, 38, 0.1);
}

.connection-status .indicator {
	width: 8px;
	height: 8px;
	border-radius: 50%;
	background-color: var(--clr-border);
	transition: background-color 0.3s;
}

.connection-status.connected .indicator {
	background-color: var(--clr-success);
}

.connection-status.disconnected .indicator {
	background-color: var(--clr-red);
}

/* 新增：自动重连提示 */
.reconnecting-notice {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background: var(--clr-background3);
	padding: 20px;
	border-radius: 12px;
	border: 2px solid var(--clr-accent);
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
	display: none;
	z-index: 300;
	text-align: center;
	align-items: center;
	gap: 10px;
}

.reconnecting-notice.visible {
	display: flex;
	flex-direction: column;
}

.reconnecting-notice .spinner {
	border: 3px solid var(--clr-background4);
	border-top: 3px solid var(--clr-accent);
	border-radius: 50%;
	width: 30px;
	height: 30px;
	animation: spin 1s linear infinite;
}

@keyframes spin {
	0% { transform: rotate(0deg); }
	100% { transform: rotate(360deg); }
}

</style>
</head>
<body>
<div class="main">
<div class="header" style="background: linear-gradient(90deg, var(--clr-background2), var(--clr-background));">
	<h1 id="caption">IRC Client</h1>
</div>

<!-- 设置栏 -->
<div class="settings-bar">
	<div class="settings-group">
		<label>WebSocket:</label>
		<input type="text" id="wsUrl" value="" placeholder="wss://irc.example.com:port/">
	</div>
	<div class="settings-group">
		<label>昵称:</label>
		<input type="text" id="nickInput" value="" placeholder="输入昵称">
	</div>
	<div class="settings-group">
		<label>频道:</label>
		<input type="text" id="channelInput" value="#abjects" placeholder="#channel">
	</div>
	<div class="settings-group">
		<label title="启用后会在断开时自动重连">
			<input type="checkbox" id="autoReconnect"> 自动重连
		</label>
	</div>
	<div class="settings-group">
		<label title="浏览器无法真正忽略SSL证书，此选项会显示解决方案">
			<input type="checkbox" id="allowInvalidSSL"> 允许无效SSL
		</label>
	</div>
	
	<button class="connect-btn" id="connectBtn" onclick="toggleConnection()">连接</button>
	<button class="log-toggle-btn" onclick="toggleLog()">查看日志</button>
	
	<!-- 新增：连接状态指示器 -->
	<div class="connection-status disconnected" id="connectionStatus">
		<span class="indicator"></span>
		<span id="statusText">未连接</span>
	</div>
</div>

<!-- SSL警告提示 -->
<div class="ssl-warning" id="sslWarning">
	<strong>⚠️ 浏览器无法忽略SSL证书错误！</strong> 请使用以下方案：<br>
	1. 改用 <code>ws://</code> 非加密连接（如果服务器支持）<br>
	2. 在浏览器中访问 <a id="sslLink" target="_blank">服务器URL</a> 并手动信任证书<br>
	3. 使用本地代理工具（如 stunnel）转发连接
</div>

<!-- 新增：重连提示 -->
<div class="reconnecting-notice" id="reconnectNotice">
	<div class="spinner"></div>
	<div>正在尝试重连...</div>
	<div id="reconnectCountdown"></div>
</div>

<!-- 日志窗口 -->
<div class="log-container" id="logContainer">
	<div class="log-header">
		<span>WebSocket日志</span>
		<div class="log-controls">
			<button onclick="clearLog()">清空</button>
			<button onclick="toggleLog()">关闭</button>
		</div>
	</div>
	<div id="logOutput"></div>
</div>

<div class="chat-container">
	<div class="channels" style="display: none;"></div>
	<nav class="channelcontents" style="display: none;"></nav>
	<input type="text" name="input" id="input" style="display: none;" onKeyPress="onKeyPress(event)" onKeyDown="onKeyDown(event)" placeholder="输入消息..."/>
</div>

</div>
</body>
<script>
////////////////////////////////////////////////////////////////
//STARTUP + INIT
var nickname = "";
var channelName = "";
var wsUrl = "";
var channels, channelContents;
var channelMap = new Map();
var activeChannel = null;
var statusChannel = null;
var input;
var PrefixChars;

var websocket = null;
var isConnected = false;
var allowInvalidSSL = false;
var autoReconnect = false; // 新增：自动重连标志
var reconnectAttempts = 0; // 新增：重连尝试次数
var maxReconnectAttempts = 5; // 新增：最大重连尝试
var reconnectDelay = 3000; // 新增：重连延迟（毫秒）

function onLoad()
{
	channels = document.getElementsByClassName("channels")[0];
	channelContents = document.getElementsByClassName("channelcontents")[0];
	input = document.getElementById("input");
	
	let url = new URL(document.location);
	if (url.hash) {
		document.getElementById('channelInput').value = url.hash;
	}
	
	if (window.frameElement) {
		document.getElementById("caption").style.display = "none";
	}
	
	// 新增：连接状态更新函数
	updateConnectionStatus(false);
}

window.addEventListener("load", onLoad, false);

// 新增：更新连接状态UI
function updateConnectionStatus(connected) {
	const statusEl = document.getElementById('connectionStatus');
	const statusText = document.getElementById('statusText');
	
	if (connected) {
		statusEl.classList.remove('disconnected');
		statusEl.classList.add('connected');
		statusText.textContent = `已连接 (${nickname})`;
	} else {
		statusEl.classList.remove('connected');
		statusEl.classList.add('disconnected');
		statusText.textContent = '未连接';
	}
}

// 日志控制
function toggleLog() {
	const logContainer = document.getElementById('logContainer');
	logContainer.classList.toggle('visible');
}

function clearLog() {
	document.getElementById('logOutput').textContent = '';
}

function writeToLog(message) {
	const logOutput = document.getElementById('logOutput');
	if (logOutput) {
		const timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false });
		logOutput.textContent += `[${timestamp}] ${message}\n`;
		logOutput.scrollTop = logOutput.scrollHeight;
	}
}

// SSL警告控制
function showSSLWarning(url) {
	if (!allowInvalidSSL) return;
	
	const warning = document.getElementById('sslWarning');
	const link = document.getElementById('sslLink');
	link.href = url.replace('wss://', 'https://').replace('ws://', 'http://');
	link.textContent = link.href;
	
	warning.classList.add('visible');
	setTimeout(() => warning.classList.remove('visible'), 15000);
}

// 新增：显示重连提示
function showReconnectNotice(show, countdown = 0) {
	const notice = document.getElementById('reconnectNotice');
	const countdownEl = document.getElementById('reconnectCountdown');
	
	if (show) {
		notice.classList.add('visible');
		if (countdown > 0) {
			countdownEl.textContent = `${Math.ceil(countdown / 1000)}秒后重试...`;
		} else {
			countdownEl.textContent = '';
		}
	} else {
		notice.classList.remove('visible');
	}
}

// 连接控制
function toggleConnection() {
	if (isConnected) {
		// 手动断开时不自动重连
		autoReconnect = false;
		document.getElementById('autoReconnect').checked = false;
		if (websocket) {
			websocket.close(1000, "User disconnected");
		}
	} else {
		doConnect();
	}
}

function validateNickname(nick) {
	if (!nick || nick.trim() === "") return false;
	return /^[a-zA-Z_\\`\[\]{}^|][a-zA-Z0-9_\\`\[\]{}^|-]*$/.test(nick);
}

function validateWsUrl(url) {
	if (!url) return false;
	return /^wss?:\/\/.+/.test(url);
}

function doConnect() {
	const wsUrlInput = document.getElementById('wsUrl');
	const nickInput = document.getElementById('nickInput');
	const channelInput = document.getElementById('channelInput');
	const sslCheckbox = document.getElementById('allowInvalidSSL');
	const reconnectCheckbox = document.getElementById('autoReconnect');
	const connectBtn = document.getElementById('connectBtn');
	
	wsUrl = wsUrlInput.value.trim();
	nickname = nickInput.value.trim();
	channelName = channelInput.value.trim();
	allowInvalidSSL = sslCheckbox.checked;
	autoReconnect = reconnectCheckbox.checked;
	
	// 验证输入
	if (!validateWsUrl(wsUrl)) {
		alert("WebSocket地址格式错误！必须以 ws:// 或 wss:// 开头");
		return;
	}
	if (!validateNickname(nickname)) {
		alert("昵称格式无效！必须以字母或特定符号开头，不能包含空格和特殊字符");
		return;
	}
	if (!channelName.startsWith('#')) {
		channelName = '#' + channelName;
	}
	
	// 重置重连计数器
	reconnectAttempts = 0;
	
	// 检查SSL证书问题
	if (allowInvalidSSL && wsUrl.startsWith('wss://')) {
		showSSLWarning(wsUrl);
		writeToLog("[SSL] 提醒用户处理证书问题");
	}
	
	// 禁用输入
	wsUrlInput.disabled = true;
	nickInput.disabled = true;
	channelInput.disabled = true;
	sslCheckbox.disabled = true;
	reconnectCheckbox.disabled = true;
	connectBtn.textContent = '连接中...';
	connectBtn.disabled = true;
	
	// 清空频道
	channels.innerHTML = '';
	channelContents.innerHTML = '';
	channelMap.clear();
	
	statusChannel = new Tab_Create("Status", "Status Window", false);
	
	writeToLog(`[系统] 正在连接: ${wsUrl}`);
	WebSocket_Connect(wsUrl);
}

function onDisconnect() {
	isConnected = false;
	const wsUrlInput = document.getElementById('wsUrl');
	const nickInput = document.getElementById('nickInput');
	const channelInput = document.getElementById('channelInput');
	const sslCheckbox = document.getElementById('allowInvalidSSL');
	const reconnectCheckbox = document.getElementById('autoReconnect');
	const connectBtn = document.getElementById('connectBtn');
	
	// 恢复输入状态
	wsUrlInput.disabled = false;
	nickInput.disabled = false;
	channelInput.disabled = false;
	sslCheckbox.disabled = false;
	reconnectCheckbox.disabled = false;
	connectBtn.textContent = '连接';
	connectBtn.disabled = false;
	connectBtn.classList.remove('disconnect');
	
	// 更新状态
	updateConnectionStatus(false);
	showReconnectNotice(false);
	
	// 隐藏聊天界面
	document.querySelector('.channels').style.display = 'none';
	document.querySelector('.channelcontents').style.display = 'none';
	document.getElementById('input').style.display = 'none';
	
	writeToLog(`[系统] 已断开连接`);
	
	// 尝试自动重连
	if (autoReconnect && reconnectAttempts < maxReconnectAttempts) {
		reconnectAttempts++;
		const delay = reconnectDelay * reconnectAttempts; // 指数退避
		writeToLog(`[重连] ${Math.floor(delay / 1000)}秒后尝试第 ${reconnectAttempts}/${maxReconnectAttempts} 次重连...`);
		showReconnectNotice(true, delay);
		
		setTimeout(() => {
			showReconnectNotice(false);
			if (!isConnected && autoReconnect) {
				writeToLog(`[重连] 正在尝试重新连接...`);
				doConnect();
			}
		}, delay);
	} else if (autoReconnect && reconnectAttempts >= maxReconnectAttempts) {
		writeToLog(`[重连] 达到最大重连次数，停止尝试`);
		autoReconnect = false;
		reconnectCheckbox.checked = false;
		alert('自动重连失败，请检查网络或服务器设置');
	}
}

////////////////////////////////////////////////////////////////
//UI 
function onKeyPress(e) {
	if(e && e.keyCode == 13) {
		send();
	}
}

function onKeyDown(e) {
	if(e.keyCode == 9)
	{
		if(e.preventDefault) 
		{
			e.preventDefault();
		}
		// TODO: 实现昵称补全功能
		console.log("TODO: TAB KEY - Nickname completion");
		return false;
	}
}

function Tab_onClick(evt) {
	let chanName = evt.currentTarget.value;
	Tab_Show(chanName);
}

function Tabs_Hide()
{
	let i, tabcontent, tablinks;
	tabcontent = document.getElementsByClassName("channelcontent");
	for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	}
	tablinks = document.getElementsByClassName("channel");
	for (i = 0; i < tablinks.length; i++) {
		tablinks[i].className = tablinks[i].className.replace(" active", "");
	}
}

function Tab_Show(name) {
	let channel = channelMap.get(name);
	Tabs_Hide();
	if (channel && channel.channel) {
		channel.channel.style.display = "flex";
		channel.button.className += " active";
		activeChannel = channel;
	}
}

function HTML_escape(text)
{
	if (!text)
		return "";
	let map = {
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;',
		'"': '&quot;',
		"'": '&#039;'
	};
	return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

function sortUserList(user_a, user_b)
{
	if (user_a[0][0] === user_b[0][0])
		return user_a[1].localeCompare(user_b[1], undefined, { sensitivity: 'accent' });
	if (!PrefixChars || !PrefixChars[1]) return 0;
	return PrefixChars[1].indexOf(user_a[0][0]) - PrefixChars[1].indexOf(user_b[0][0]);
}

function Tab_Create(name, topic, createlist)
{
	Tabs_Hide();
	this.name = name;
	let escapedName = HTML_escape(name);
	this.button = document.createElement("button");
		this.button.innerHTML = escapedName;
		this.button.value = escapedName;
		this.button.onclick = Tab_onClick;
		this.button.className = "channel active";
		let x = document.createElement("button");
			x.innerHTML = "×";
			x.onclick = Tab_Close;
			x.value = escapedName;
			x.className = "x";
		this.button.appendChild(x);
	channels.appendChild(this.button);
	this.channel = document.createElement("nav");
		this.channel.className = "channelcontent";
		this.channelnav = document.createElement("nav");
			this.topic = document.createElement("h3");
			this.topic.innerHTML = HTML_escape(topic || "no channeltopic available");
		this.channelnav.appendChild(this.topic)
		this.content = document.createElement("nav");
		this.channelnav.appendChild(this.content);
		this.channel.appendChild(this.channelnav);
		if (createlist) 
		{
			this.userlist = document.createElement("ul");
			this.users = [];
			this.names_end = true;
			this.channel.appendChild(this.userlist);
		}
	channelContents.appendChild(this.channel);
	channelMap.set(name, this);
	activeChannel = this;
}

function Tab_Close(evt)
{
	doSend("part " + evt.currentTarget.value);
}

function Channel_Destroy(name) {
	let channel = channelMap.get(name);
	if (!channel)
		return;
	channel.button.remove();
	channel.channel.remove();
	if (activeChannel == channel)
	{
		activeChannel = statusChannel;
	}
	channelMap.delete(name);
	if (activeChannel) {
		Tab_Show(activeChannel.name);
	}
}

// ... 其余 UI 函数保持不变 ...

////////////////////////////////////////////////////////////////
//WEBSOCKET STUFF - 增强版

function WebSocket_Connect(wsUri)
{
	try {
		// 清理旧连接
		if (websocket) {
			websocket.onclose = null;
			websocket.onerror = null;
			websocket.onopen = null;
			websocket.onmessage = null;
			if (websocket.readyState !== WebSocket.CLOSED) {
				websocket.close(1000, "Reconnecting");
			}
		}
		
		writeToLog(`[WebSocket] 正在创建连接: ${wsUri}`);
		websocket = new WebSocket(wsUri);
		websocket.binaryType = 'blob';
		
		// 设置超时处理
		const connectTimeout = setTimeout(() => {
			if (websocket && websocket.readyState !== WebSocket.OPEN) {
				writeToLog(`[ERROR] 连接超时 (30秒)`);
				websocket.close(1006, "Connection timeout");
			}
		}, 30000);
		
		websocket.onclose = function(evt) { 
			clearTimeout(connectTimeout);
			onClose(evt);
		};
		websocket.onerror = function(evt) { onError(evt) };
		websocket.onopen = function(evt) { 
			clearTimeout(connectTimeout);
			onOpen(evt);
		};
		websocket.onmessage = function(evt) { onMessage(evt) };
		
	} catch (e) {
		writeToLog(`[ERROR] WebSocket创建失败: ${e.message}`);
		onDisconnect();
		alert(`连接失败: ${e.message}\n\n如果是SSL证书错误，请勾选"允许无效SSL"查看解决方案`);
	}
}

function onClose(evt)
{
	isConnected = false;
	
	// 详细分析关闭原因
	let reason = evt.reason || '连接关闭';
	let code = evt.code;
	let logMsg = `[CLOSE] Code: ${code}`;
	
	// 根据关闭码分类错误
	switch(code) {
		case 1000:
			logMsg += ' (正常关闭)';
			break;
		case 1006:
			logMsg += ' (异常断开 - 可能SSL证书错误)';
			if (allowInvalidSSL) showSSLWarning(wsUrl);
			break;
		case 1005:
			logMsg += ' (无状态码)';
			break;
		case 1011:
			logMsg += ' (服务器异常)';
			break;
		default:
			if (code >= 4000 && code <= 4999) {
				logMsg += ' (应用层错误)';
			}
	}
	logMsg += ` - ${reason}`;
	
	writeToScreen("var(--clr-font)", "DISCONNECTED", statusChannel);
	writeToLog(logMsg);
	
	// 清理 WebSocket 引用
	if (websocket) {
		websocket = null;
	}
	
	// 触发断开处理
	onDisconnect();
}

function onError(evt)
{
	// 分类错误类型
	let errorType = 'WebSocket错误';
	if (evt && evt.target && evt.target.readyState === WebSocket.CONNECTING) {
		errorType = '连接失败';
	} else if (evt && evt.target && evt.target.readyState === WebSocket.OPEN) {
		errorType = '消息发送失败';
	}
	
	writeToScreen("var(--clr-red)", `ERROR: ${errorType}`, statusChannel);
	writeToLog(`[ERROR] ${errorType}: ${evt.data || '未知错误'}`);
	
	// 针对 SSL 错误的特殊处理
	if (allowInvalidSSL && wsUrl.startsWith('wss://')) {
		showSSLWarning(wsUrl);
	}
}

function onOpen(evt)
{
	isConnected = true;
	reconnectAttempts = 0; // 重置重连计数
	
	writeToScreen("var(--clr-font)", "CONNECTED", statusChannel);
	writeToLog(`[OPEN] WebSocket连接成功: ${wsUrl}`);
	
	// 更新UI
	updateConnectionStatus(true);
	document.querySelector('.channels').style.display = 'flex';
	document.querySelector('.channelcontents').style.display = 'flex';
	document.getElementById('input').style.display = 'block';
	
	const connectBtn = document.getElementById('connectBtn');
	connectBtn.textContent = '断开';
	connectBtn.disabled = false;
	connectBtn.classList.add('disconnect');
	
	// 发送 IRC 认证
	doSend("user websocket * * :Abjects WebSocket User");
	doSend("nick " + nickname);
}

function onMessage(evt)
{
	rawData = evt.data;
	writeToLog(`← RECV: ${typeof rawData === 'string' ? rawData : '[Blob数据]'}`);
	
	// 处理二进制数据
	if (rawData instanceof Blob)
	{
		let fileReader = new FileReader();
		fileReader.addEventListener("loadend", handleBinaryInput);
		fileReader.readAsText(rawData);
	}
	else
	{
		process(rawData);
	}
}

function handleBinaryInput(event)
{
	let fileReader = event.target;
	let raw = fileReader.result;
	writeToLog(`← RECV (Blob→Text): ${raw}`);
	process(raw);
}

function doSend(message)
{
	if (websocket && websocket.readyState === WebSocket.OPEN) {
		websocket.send(message);
		writeToLog(`→ SEND: ${message.trim()}`);
	} else {
		writeToLog(`[ERROR] WebSocket未连接或已关闭，无法发送: ${message.trim()}`);
		if (!isConnected) {
			writeToScreen("var(--clr-red)", "未连接，消息未发送", statusChannel);
		}
	}
}

// ... 后续 IRC 协议处理函数保持不变 ...

</script>
</html>